---
title: R02 - Objets et pipeline
slug: "02"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 2 - Objets et pipeline

:::note R√©sum√© de la s√©ance du mardi 26 septembre 2023

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Correction des exercices
1. Exemples de commandes utiles
1. Objets
1. Pipeline
1. Variables
1. Types de donn√©es
1. Tableaux et op√©rations sur les tableaux

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

Les exercices suivants se trouvent dans votre section personnelle du bloc-notes du cours, sous l'onglet *Exercices*:
- Exercice 02a: Objets et pipeline
- Exercice 02b: Collections

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::

PowerShell est un langage **orient√© objet** reposant sur le cadre logiciel _.NET Framework_. De ce fait, chaque commande (cmdlet) retourne un ou plusieurs objets. Cette particularit√© diff√®re des commandes externes et des autres langages de shell, qui retournent du texte

Les objets sont beaucoup plus facile √† interpr√©ter par des algorithmes, car on peut extraire l'information qu'on souhaite sans proc√©der √† des manipulations de cha√Ænes de caract√®res. Ils nous donnent l'opportunit√© de les manipuler √† notre guise, en les passant d'une commande √† l'autre dans ce qu'on appelle le pipeline. Or, les humains ont plus de facilit√© √† lire du texte que des objets. Donc √† la fin de la cha√Æne de commandes, l'objet r√©sultant est automatiquement converti en texte afin d'√™tre lu par l'utilisateur.

Cette s√©ance de cours porte principalement sur l'utilisation des objets qui r√©sultent des diff√©rentes commandes PowerShell ainsi que le cha√Ænage de plusieurs commandes dans le _pipeline_.


## Objets

Les commandes PowerShell retournent un ou plusieurs objets. Un objet est une structure de donn√©es, un √©l√©ment logique d'information d'une structure d√©finie par une classe (ou type). Il est compos√© de plusieurs membres, soit des propri√©t√©s (ou m√©thodes), qui repr√©sentent de l'information d√©crivant l'objet, et des m√©thodes (ou fonctions) qui posent une action sur cet objet.

### Conna√Ætre les membres d'un objet

La commande `Get-Member` permet d'obtenir la liste des propri√©t√©s et des m√©thodes offertes par cet objet. Dans le cas d'une collection d'objets, elle analyse le type d'objet dans la collection.

![image](./assets/r02/Objets-Membre01.png)

On peut sp√©cifier le type de membre pour une recherche plus cibl√©e.

![image](./assets/r02/Objets-Membre02.png)


### Obtenir une propri√©t√©

Par exemple, la commande `Get-Item` retourne l'information sur un fichier ou un dossier. Le r√©sultat de cette commande est un objet qui d√©crit le fichier ou le dossier correspondant.

![image](./assets/r02/Objets-Propriete01.png)

Si l'objet repr√©sente un fichier, il poss√®dera une propri√©t√© `.Length` qui repr√©sente sa taille, en octets. Pour acc√©der √† un membre d'un objet, on utilise le caract√®re point. Il y a plusieurs mani√®res d'identifier l'objet, soit avec des parenth√®ses, soit en le passant dans une variable.

![image](./assets/r02/Objets-Propriete02.png)


### Explorer les propri√©t√©s d'un objet

Pour explorer un objet, il est √©galement utile de demander √† lister toutes ses propri√©t√©s.

![image](./assets/r02/Objets-Propriete03.png)

Il est ainsi plus facile de trouver des propri√©t√©s int√©ressantes.


### Appeler une m√©thode

L'appel d'une m√©thode se fait de la m√™me mani√®re que pour une propri√©t√©, sauf que la m√©thode peut accepter des param√®tres. Comme une m√©thode n'est pas une commande PowerShell, les param√®tres n'ob√©issent pas aux m√™me r√®gles: ils ne sont pas nomm√©s, et doivent √™tre sp√©cifi√©s en parenth√®ses.

![image](./assets/r02/Objets-Methode01.png)

Si la m√©thode qu'on appelle n'a pas de param√®tre, il faut √©crire les parenth√®ses quand m√™me.

![image](./assets/r02/Objets-Methode02.png)


### Conna√Ætre le type d'un objet

Une mani√®re de conna√Ætre le type d'un objet est d'appeler sa m√©thode GetType(). Cette m√©thode existe dans tous les types d'objets, et retourne un objet qui d√©crit le type de cet objet.

![image](./assets/r02/Objets-Type01.png)

Par exemple, la commande Get-Item peut retourner des fichiers et des dossiers, qui sont des structures tr√®s diff√©rentes. Selon l'√©l√©ment que l'on tente d'obtenir, le type de l'objet r√©sultant sera diff√©rent.

![image](./assets/r02/Objets-Type02.png)

Si la commande retourne plusieurs objets, alors le type de l'objet retourn√© sera un array, c'est-√†-dire un objet qui contient plusieurs objets. On les identifie avec des crochets [ ] √† la fin de leur type.

![image](./assets/r02/Objets-Type03.png)


## Le _pipeline_

Le _pipeline_ est le m√©canisme par lequel l'information circule dans une session PowerShell. Il permet de cha√Æner des commandes afin que l'objet sortant d'une commande entre dans la prochaine pour y √™tre trait√©. Le caract√®re pour cha√Æner les commande est la barre verticale `|` (appel√©e "_pipe_" ou "_tube_").

Pour mieux conceptualiser le _pipeline_, on peut voir chaque commande comme une machine qui prend un ou plusieurs objets en entr√©e (_input_), effectue un traitement en tenant compte de ces intrants (qui peuvent impliquer des appels au syst√®me d'exploitation), puis produit un objet en sortie (_output_) et le jette dans le _pipeline_.

![image](./assets/r02/Pipeline01.png)

Une commande produisant un objet en sortie (ou un objet d√©pos√© directement dans le _pipeline_) sera donc pass√© en entr√©e √† la commande suivante, qui le passera dans un de ses param√®tres, le traitera et produira un autre objet de type diff√©rent, qui pourra √™tre pass√© √† la prochaine commande, et ainsi de suite.

![image](./assets/r02/Pipeline02.png)

√Ä la fin du _pipeline_, l'objet qui s'y trouve "tombe" dans la console (le host), o√π il sera automatiquement converti en texte selon plusieurs r√®gles r√©gies √† la fois par la configuration de PowerShell et par la nature de cet objet.

![image](./assets/r02/Pipeline03.png)

On peut √©viter √† l'objet de tomber dans la console en le "pipant" dans une autre commande (habituellement, avec le verbe Out-), ou bien en l'affectant √† une variable.

![image](./assets/r02/Pipeline04.png)

Si on souhaite se d√©barrasser de l'objet r√©sultant, il suffit de terminer la cha√Æne de _pipeline_ par la commande Out-Null, qui d√©signe simplement une sortie vers rien du tout.

![image](./assets/r02/Pipeline05.png)


### S√©lection

Plusieurs commandes, et particuli√®rement celles dont le verbe est `Get`, produisent des objets en sortie dans le pipeline, qui poss√®dent des propri√©t√©s. Certains objets en poss√®dent un grand nombre, et lorsqu'ils sont affich√©s sous forme de texte dans la console, parfois seules les propri√©t√©s principales sont affich√©es. Une op√©ration simple consiste √† "extraire" de cet objet certaines propri√©t√©s. Cette op√©ration se nomme la "s√©lection" et peut √™tre r√©alis√©e avec la commande `Select-Object`. 

La s√©lection ne "transforme" pas vraiment l'objet, elle en produit plut√¥t une copie transform√©e.

On peut cr√©er des objets compos√©s de certaines propri√©t√©s en sp√©cifiant le param√®tre `-Property` de la commande `Select-Object`.

Par exemple, la commande suivante permet de "transformer" l'objet repr√©sentant le service "winmgmt" en objet compos√© uniquement de ses propri√©t√©s `Name`et `Status`.

```powershell
Get-Service -Name "winmgmt" | Select-Object -Property "Name", "Status"
```

On remarque qu'√† l'ex√©cution de cette commande, il reste des ent√™tes de colonnes. Alternativement, on peut extraire seulement la **valeur** de la propri√©t√© en sp√©cifiant le param√®tre `-ExpandProperty`.

```powershell
Get-Service -Name "winmgmt" | Select-Object -ExpandProperty "Status"
```

![image](./assets/r02/Pipeline-Selection01.png)


### Commandes de formatage

Lorsqu'un objet arrive au bout du _pipeline_, il est automatiquement converti en texte par PowerShell afin d'√™tre affich√© dans la console dans un format lisible par l'utilisateur. Comme un objet poss√®de des donn√©es brutes, PowerShell doit faire un choix dans sa mani√®re de repr√©senter textuellement l'objet √† l'√©cran. Le formatage se fait en fonction de plusieurs facteurs, dont la nature de la commande, le nombre de propri√©t√©s de l'objet, etc. On peut utiliser des commandes de formatage (typiquement, des commandes d√©butant par le verbe `Format-`.)

| Commande | Alias | Description |
| -- | -- | -- |
| `Format-List` | `fl` | Convertit l'objet en texte sous forme de liste |
| `Format-Table` | `ft` | Convertit l‚Äôobjet en texte sous forme de tableau (moins d√©taill√©) |
| `Format-Wide` | `fw` | Convertit l‚Äôobjet en texte r√©parti sur la largeur (tr√®s sommaire) |
| `Format-Hex` | `fhx` | Convertit des donn√©es en texte montrant leur valeur hexad√©cimale |

On peut √©galement effectuer des s√©lections √† l'int√©rieur m√™me de la commande de formatage. 

![image](./assets/r02/Pipeline-Formatage01.png)

C'est pratique pour explorer toutes les propri√©t√©s d'un objet. On peut le formater sous forme de liste et forcer l'affichage de toutes ses propri√©t√©s avec le symbole *.

![image](./assets/r02/Pipeline-Formatage02.png)

:::warn

Une fois un objet pass√© dans la commande de formatage, il est automatiquement converti en texte. C'est pourquoi le formatage est g√©n√©ralement utilis√© √† la toute fin du pipeline, ou avant une commande de sortie (`Out-`).

:::

### Commandes de sortie

Par d√©faut, lorsqu'un objet arrive au bout du _pipeline_, il est affich√© dans la console (_host_) apr√®s avoir √©t√© converti en texte. On peut rediriger l'objet vers une autre sortie, comme un fichier ou une imprimante. Voici quelques commandes de sortie disponibles:

| Commande | Alias | Description |
| -- | -- | -- |
| `Out-Default` |  | Envoie l‚Äôobjet vers la sortie par d√©faut (implicite, par d√©faut Out-Host) |
| `Out-Host` | `oh` | Envoie l‚Äôobjet vers la console (il sera converti automatiquement en texte) |
| `Out-File` |  | Envoie l‚Äôobjet vers un fichier (il sera converti automatiquement en texte) |
| `Out-Null` |  | Envoie l‚Äôobjet vers le n√©ant (l‚Äôobjet sera d√©truit) |
| `Out-String` | `oss` | Convertit les objets en cha√Æne de caract√®res |
| `Out-Printer` | `lp` | Envoie l‚Äôobjet vers une imprimante |
| `Out-GridView` | `ogv` | Sort l‚Äôobjet vers une grille graphique (dans une fen√™tre s√©par√©e) |


### Param√®tre PassThru

Ce ne sont pas toutes les commandes qui produisent un objet sur le pipeline. Certaines commandes n'en produisent pas, soit parce qu'elles n'ont pas √† le faire, soit parce que la plupart du temps, on n'a pas besoin de cet objet.

Par exemple, la commande `Start-Process` sert √† d√©marrer un processus (un ex√©cutable). Par d√©faut, lorsqu'on lance cette commande, elle se contente de demander √† Windows de cr√©er un processus et ne retourne rien. 

![image](./assets/r02/Pipeline-PassThru01.png)

Mais il peut arriver qu'on souhaite enregistrer des informations sur le processus nouvellement cr√©√©. Certaines commandes offrent un param√®tre `-PassThru`, qui permettent de forcer la production d'un objet d√©crivant le r√©sultat de la commande. Dans ce cas, la commande `Start-Process` produit un objet d√©crivant le processus.

![image](./assets/r02/Pipeline-PassThru02.png)


### Commande Tee-Object

La commande `Tee-Object` sert √† enregistrer un objet dans une variable ou un fichier, en le relayant en m√™me temps sur le pipeline.

![image](./assets/r02/Pipeline-Tee01.png)

![image](./assets/r02/Pipeline-Tee02.png)

## Les variables

Les variables en PowerShell sont identifi√©es avec le pr√©fixe `$`. Par exemple, la variable _Foo_ s'√©crit `$Foo` dans le code PowerShell. Le nom de la variable est _Foo_, et le caract√®re `$` indique √† PowerShell qu'il s'agit d'une variable.

Une variable contient un objet. L'op√©ration consistant √† mettre un objet dans une variable se nomme une affectation, et on la r√©alise √† l'aide de l'op√©rateur d'affectation, `=`. Cet op√©rateur r√©cup√®re l'objet r√©sultant √† la fin du _pipeline_ afin de le stocker dans la variable, plut√¥t que de le laisser tomber dans la console.

Pour obtenir le contenu d'une variable, on utilise simplement son nom avec le caract√®re `$`. Cela a pour effet d'envoyer son contenu dans le _pipeline_. On peut aussi utiliser cette variable pour passer un objet dans un param√®tre.

![image](./assets/r02/Variables01.png)

Une variable contient un objet, donc on peut l'utiliser pour acc√©der √† toutes les m√©thodes et tous les attributs offerts par cet objet.

![image](./assets/r02/Variables02.png)

On peut conna√Ætre la liste de toutes les variables d√©clar√©es avec la commande `Get-Variable`.

![image](./assets/r02/Variables03.png)


### Variables pr√©d√©finies

Certaines variables sont pr√©d√©finies par PowerShell.

| Variable | Description |
| -- | -- |
| `$true` | Repr√©sente la valeur bool√©enne vraie |
| `$false` | Repr√©sente la valeur bool√©enne fausse |
| `$null` | Repr√©sente la valeur nulle |
| `$PID` | Le num√©ro d'identification du processus courant |
| `$PWD` | Repr√©sente le r√©pertoire courant |
| `$args` | Contient un tableau des arguments pass√©s √† l'appel d'une fonction ou d'un script |
| `$error` | Liste des erreurs lors de la session |
| `$PSVersionTable` | Tableau des versions de PowerShell |
| `$Host` | Objet qui permet de modifier l'interface PowerShell |
| `$Home` | Le chemin du r√©pertoire de l'utilisateur (typiquement `C:\Users\nomdutilisateur`) |
| `$PSHome` | Le chemin dans lequel PowerShell est install√© |
| `$PSCulture` | La culture de la session PowerShell (`fr-CA`, `en-US`, etc.) |
| `$_` ou `$PSItem` | Valeur courante dans le _pipeline_ |
| ... | |

### Variables d'environnement

Le syst√®me d'exploitation offre √† tous les processus un ensemble de variables g√©r√©es par le syst√®me et qui procurent de l'information sur l'environnement d'ex√©cution. 

Voici quelques variables d'environnement (mais il y en a plusieurs autres).

| Variable (PoSH) | Description |
| -- | -- |
| `$env:COMPUTERNAME` | Le nom d'h√¥te de l'ordinateur |
| `$env:USERNAME` | Le nom de l'utilisateur |
| `$env:USERDOMAIN` | Le nom du domaine de l'utilisateur courant (format NetBIOS) |
| `$env:USERDNSDOMAIN` | Le nom du domaine de l'utilisateur courant (format FQDN) |
| `$env:LOGONSERVER` | Le nom du contr√¥leur de domaine ayant authentifi√© l'utilisateur lors de son logon |
| `$env:UserProfile` | Le chemin vers le profil de l'utilisateur (typiquement C:\Users\nomdutilisateur) |
| `$env:APPDATA` | Chemin vers le r√©pertoire AppData/Roaming de l'utilisateur courant |
| `$env:LocalAppData` | Chemin vers le r√©pertoire AppData/Local de l'utilisateur courant |
| `$env:HOMEDRIVE` | Le lecteur sur lequel est situ√© le profil de l'utilisateur |
| `$env:HOMEPATH` | Le chemin relatif du profil utilisateur sur le lecteur HOMEDRIVE |
| `$env:TEMP` | Le chemin vers le r√©pertoire temporaire de l'utilisateur (m√™me que TMP) |
| `$env:TMP` | Le chemin vers le r√©pertoire temporaire de l'utilisateur (m√™me que TEMP) |
| `$env:ALLUSERSPROFILE` | Le chemin vers le profil utilisateur commun √† tous les utilisateurs (programdata) |
| `$env:ProgramData` | Le chemin du r√©pertoire qui contiennent les configurations du syst√®me |
| `$env:ProgramFiles` | Le chemin vers le r√©pertoire contenant les fichiers de programme |
| `$env:{ProgramFiles (x86)}` | Le chemin vers le r√©pertoire des fichiers de programme 32-bits (WoW64) |
| `$env:Path` | La liste des chemins qui contiennent des commandes ex√©cutables |
| `$env:PATHEXT` | La liste des extensions √† consid√©rer comme ex√©cutables |
| `$env:PUBLIC` | Le chemin vers le r√©pertoire public (partag√© par tous les profils) |
| `$env:NUMBER_OF_PROCESSORS` | Le nombre de processeurs logiques install√©s dans le syst√®me |
| `$env:PROCESSOR_ARCHITECTURE` | L'architecture du processeur (x86, amd64, ia64, arm64, etc.) |
| `$env:ComSpec` | Le chemin vers l'interpr√©teur de commande par d√©faut |
| `$env:OneDrive` | Le chemin vers le r√©pertoire de synchronisation de OneDrive |
| `$env:OneDriveCommercial` | Le chemin vers le r√©pertoire de synchronisation de OneDrive For Business |
| `$env:SystemDrive` | Le lecteur sur lequel Windows est install√© (typiquement C:) |
| `$env:SystemRoot` | Le chemin vers le r√©pertoire o√π Windows est install√© (typiquement C:\Windows) |
| `$env:PSModulePath` | La liste des chemins qui contiennent des modules PowerShell |

Dans l'interpr√©teur de commande classique (cmd), et √† plusieurs autres endroits du syst√®me (comme dans le shell graphique, le registre, etc.), les variables d'environnement sont accessibles en les entourant de deux symboles `%`.

![image](./assets/r02/Variables-Env01.png)

![image](./assets/r02/Variables-Env02.png)

La commande Set permet d'obtenir la liste des variables d'environnement.

![image](./assets/r02/Variables-Env03.png)

Sous PowerShell, la syntaxe est diff√©rente. On utilise le pr√©fixe `$env:` pour y acc√©der.

![image](./assets/r02/Variables-Env04.png)

Pour obtenir la liste, on fait un `Get-ChildItem` sur le lecteur `env:`, qui contient toutes les variables d'environnement du processus.

![image](./assets/r02/Variables-Env05.png)

:::caution

Les variables d'environnement sont rattach√©es √† un processus particulier, et chaque processus cr√©√© h√©rite des variables d'environnement du processus parent. Ainsi, si on fait des modification √† une variable d'environnement, celle-ci ne sera modifi√©e que dans ce processus et pas les autres. De plus, le changement sera d√©truit apr√®s la fin du processus, lorsque la fen√™tre PowerShell est ferm√©e. Il est possible de modifier une variable d'environnement de mani√®re permanente, mais nous verrons cela dans une s√©ance ult√©rieure.

:::

## Transcription

Il est possible de demander √† PowerShell d'enregistrer automatiquement dans un fichier tout ce qui se fait dans la fen√™tre. C'est pratique pour garder des traces de ce qu'on fait. La commande pour tirer profit de cette fonctionnalit√© est `Start-Transcript`. On fournit √† la commande le chemin vers un fichier, et tout ce qui est √©crit et affich√© dans la console y est sauvegard√©. Pour terminer l'enregistrement, il suffit de lancer `Stop-Transcript`, ou simplement de mettre fin √† la session PowerShell.

![image](./assets/r02/Transcript01.png)

![image](./assets/r02/Transcript02.png)


## Types de donn√©es

Tout objet en PowerShell poss√®de un type, et s'il est dans une variable, celle-ci poss√®de √©galement ce type. Il existe plusieurs types distincts.

### Nombres entiers

| Type | Description | Valeur minimale | Valeur maximale |
| -- | -- | -- | -- |
| `[byte]` | Entier non sign√© de 8 bits | 0 | 255 | 
| `[sbyte]` | Entier sign√© de 8 bits | -128 | 127 |
| `[int16]` | Entier sign√© de 16 bits | -32 768 | 32 767 |
| `[uint16]` | Entier non sign√© de 16 bits | 0 | 65 535 |
| `[int32]` _ou_ `[int]` |Entier sign√© de 32 bits | -2 147 483 648 | 2 147 483 647 |
| `[uint32]` | Entier non sign√© de 32 bits | 0 | 4 294 967 295 |
| `[int64]` _ou_ `[long]` | Entier sign√© de 64 bits | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807 |
| `[uint64]` | Entier non sign√© de 64 bits | 0 | 18 446 744 073 709 551 615 |

:::info
Par d√©faut, les nombres entiers sont de type `[int32]` (ou `[int64]` s'il sont trop grands). Pour qu'ils soient de type diff√©rent, il faut le sp√©cifier devant la valeur. (Par exemple, `[uint32]42`).
:::


### Nombre √† virgule flottante (d√©cimaux)

| Type | Description | Pr√©cision | Valeur minimale/maximale |
| -- | -- | -- | -- |
| `[single]` _ou_ `[float]` | Nombre √† virgule flottante de pr√©cision simple | 32 bits | ¬± 3,402 823 E+38 |
| `[double]` | Nombre √† virgule flottante de pr√©cision double (par d√©faut) | 64 bits | ¬± 1,79 769 313 486 232 E+308 |
| `[decimal]` | Nombre d√©cimal | 128 bits | ¬± 79 228 162 514 264 337 593 543 950 335 |

:::info
Par d√©faut, les nombres non entiers sont de type `[double]`. Pour qu'ils soient d'un autre type, il faut le sp√©cifier devant la valeur (par exemple, `[single] 3.14`).

Les nombres √† virgule flottante sont la m√©thode qu'emploient les ordinateurs pour repr√©senter les nombres non entiers. Ils combinent une mantisse et un exposant, comme dans la notation scientifique, ce qui permet de repr√©senter de tr√®s grands nombres mais en sacrifiant de la pr√©cision. Vous pouvez suivre ce lien pour en apprendre davantage sur la virgule flottante en informatique. 
:::


### Autres types de donn√©es

| Type | Description | Example |
| -- | -- | -- |
| `[boolean]` _ou_ `[bool]` | Valeur bool√©enne (`$true` ou `$false`) | `$true` |
| `[string]` | Cha√Æne de caract√®res √† taille fixe | `"allo"` |
| `[char]` | Caract√®re unicode de 16 bits | `[char]"X"` |
| `[datetime]` | Date et heure | `Get-Date` | 
| `[hashtable]` | Table de hachage | `@{a = 1; b = 2; c = 3}` |
| `[pscustomobject]` | Objet dictionnaire | `[pscustomobject]@{a = 1; b = 2; c = 3}` |
| `[object]` | Type qui d√©crit n'importe quel objet (toutes les classes d√©rivent de `[object]`) |  |
| `[array]` _ou_ `[type[]]` | Tableau (contient plusieurs objets, dans un ordre pr√©cis) | `@(1, 2, 3)` |
| `[scriptblock]` | Bloc de script pr√©compil√© | `$script = [scriptblock]{ # une ou plusieurs commandes‚Ä¶ }` |
| `[math]` | Expose des fonctions math√©matiques | `[math]::Pow(10,2)` |

Pour en savoir plus sur les types de donn√©es PowerShell, consultez [cette page](https://learn.microsoft.com/fr-fr/powershell/scripting/lang-spec/chapter-04?view=powershell-5.1).


### Valeurs minimum et maximum

Toute donn√©e est un objet, et un objet poss√®de un type. Dans le paradigme orient√© objet, un type est une classe, et un objet de ce type est une instance de cette classe. Les classes sont en quelque sorte des plans, ou mod√®les, qui dictent √† quoi une donn√©e doit ressembler. Une classe est repr√©sent√©e entre crochets `[` et `]`. 

La classe elle-m√™me expose des m√©thodes et des attributs, dits statiques, qui d√©crivent certains aspects de ce type. Alors qu'on peut acc√©der aux m√©thodes et attributs d'un objet (ou instance de classe) avec un point `.` , on acc√®de les m√©thodes et attributs d'une classe avec un double deux points `::`.

Dans le cas des types num√©riques, des attributs de la classe correspondant au type nous permettent d'obtenir les valeurs minimum et maximum que ce type supporte.

![image](./assets/r02/Types-MethodeClasse01.png)


### Conversion de types

On peut convertir les valeurs d'un type √† l'autre, et les castant, c‚Äôest-√†-dire en for√ßant le type.

![image](./assets/r02/Types-Conversion01.png)

Il faut toutefois faire attention que la valeur soit compatible avec le type vers lequel on souhaite la convertir.

![image](./assets/r02/Types-Conversion02.png)


### Suffixes de multiplication des octets

PowerShell nous offre un moyen de calculer facilement les grandeurs (Ko, Mo, Go, etc.)

| Suffixe | Signification | Valeur |
| -- | -- | -- |
| Kb | Kibioctet | 2<sup>10</sup> = 1024 | 
| Mb | M√©bioctet | 2<sup>20</sup> = 1024<sup>2</sup> = 1 048 576 | 
| Gb | Gibioctet | 2<sup>30</sup> = 1024<sup>3</sup> = 1 073 741 824 |
| Tb | T√©bioctet | 2<sup>40</sup> = 1024<sup>4</sup> = 1 099 511 627 776 |
| Pb | P√©bioctet | 2<sup>50</sup> = 1024<sup>5</sup> = 1 125 899 906 842 624 |



Cela peut s'av√©rer tr√®s pratique pour, par exemple, calculer les tailles de fichiers.

![image](./assets/r02/Types-MultiplicationOctets01.png)


### Cha√Ænes de caract√®res

Les cha√Ænes de caract√®res sont un type de donn√©es particuli√®rement commun dans tous les langages de programmation, et PowerShell ne fait pas exception.

#### Guillemets

En PowerShell, les cha√Ænes de caract√®res sont balis√©es par des guillemets. Les guillemets simples et doubles sont accept√©s.

![image](./assets/r02/r03_02a.png)

Un type de guillemet compris dans une cha√Æne balis√©e par l'autre type de guillemets sera affich√© tel quel.

![image](./assets/r02/r03_02b.png)

Par contre, les deux types de guillemets se comportent diff√©remment avec les variables. Le variables √©crites dans une cha√Æne √† guillemets doubles sont r√©solues, alors que celles dans une cha√Æne √† guillemets simples ne le sont pas.

![image](./assets/r02/r03_02c.png)

Pour √©crire √† la fois des guillemets doubles dans une cha√Æne et r√©soudre une variable, on peut soit doubler les guillemets doubles (un double-double-guillemet repr√©sente le caract√®re du double-guillemet), ou encore mettre un caract√®re d'√©chappement (le backtick) juste avant pour le forcer √† √™tre repr√©sent√© comme caract√®re dans la cha√Æne.

![image](./assets/r02/r03_02d.png)

Pour les cas plus complexes, on peut construire une variable temporaire au sein d'une cha√Æne de caract√®res, avec la formule $(). C'est pratique si on veut non pas r√©soudre une variable dans une cha√Æne, mais plut√¥t r√©soudre une expression.

![image](./assets/r02/r03_02e.png)

De cette mani√®re, on peut r√©soudre n'importe quelle expression au sein de la cha√Æne de caract√®res.

![image](./assets/r02/r03_02f.png)

#### Concat√©nation

On peut aussi concat√©ner deux cha√Ænes de caract√®res avec l'op√©rateur de concat√©nation `+`.

![image](./assets/r02/r03_02g.png)

Une autre option pour unir plusieurs √©l√©ments d'une cha√Æne est d'utiliser l'op√©rateur de formatage `-f`. On √©crit la cha√Æne de caract√®res mais en y ins√©rant des jetons {n}. Ceux-ci seront remplac√©s par le contenu des variables sp√©cifi√©es apr√®s l'op√©rateur `-f`.

![image](./assets/r02/r03_02h.png)

Ou encore, on peut toujours ins√©rer les variables directement dans la cha√Æne, lorsqu'on utilise des guillemets doubles.

![image](./assets/r02/r03_02i.png)


### Op√©rateurs

#### Op√©rateurs arithm√©tiques

| Op√©rateur | Description |
| -- | -- |
| `+` | Addition |
| `-` | Soustraction |
| `*` | Multiplication |
| `/` | Division |
| `%` | Modulo |

![image](./assets/r02/r03_03a.png)

L'op√©rateur modulo sert √† donner le reste de la division enti√®re. En PowerShell, c'est le caract√®re `%` qui d√©signe cet op√©rateur. Pour la division enti√®re par contre, PowerShell n'offre pas d'op√©rateur, √† la diff√©rence de plusieurs autres langages. L'op√©rateur `/` produit une valeur de type `[double]` si le r√©sultat n'est pas un nombre entier, et caster le r√©sultat √† `[int]` arrondit ce r√©sultat √† l'entier le plus proche. Par cons√©quent, la composante enti√®re de la division peut √™tre obtenue en appelant la fonction plancher de la classe utilitaire Math.

![image](./assets/r02/r03_03b.png)

#### Op√©rateurs de comparaison

Les op√©rateurs de comparaison retournent une valeur bool√©enne vraie ou fausse dans le pipeline, selon un crit√®re pr√©cis. On les utilise entre deux valeurs.

| Op√©rateur | Description | Exemple |
| -- | -- | -- |
| `-eq` | √âgal √† | `0 -eq 0` |
| `-ne` | Pas √©gal √† | `0 -ne "allo"` |
| `-gt` | Plus grand que | `1 -gt 0` |
| `-ge` | Plus grand ou √©gal √† | `0 -ge 0` |
| `-lt` | Plus petit que | `-1 -lt 0` |
| `-le` | Plus petit ou √©gal √† | `0 -le 0` |
| `-like` | Comparaison avec wildcard | `"allo" -like "a*"` |
| `-notlike` | Inverse de `-like` | `"bonjour" -notlike "a*"` |
| `-match` | Comparaison regex | `"514-555-0123" -match "\d{3}-\d{3}-\d{4}"` |
| `-nomatch` | Inverse de `-match` | `"(514) 555-0123" -match "\d{3}-\d{3}-\d{4}"` |
| `-is` | Comparaison de type | `1.1 -is [double]` |
| `-isnot` | Inverse de `-is` | `1 -isnot [double]` |
| `-and` | Et logique | `(0 -eq 0) -and ("pomme" -eq "pomme")` |
| `-or` | Ou logique | `(0 -eq 0) -or ("pomme" -eq "banane")` |
| `-not` _ou_ `!` | Non logique | `-not (1 -eq 0)` <br/> `!(1 -eq 0)` |
| `-xor` | Ou exclusif | `$true -xor $false` |

![image](./assets/r02/r03_03c.png)


#### Op√©rateurs d'affectation

Les op√©rateurs d'affectation modifient l'op√©rande de gauche.

| Op√©rateur	Description | Exemple | √âquivalent |
| -- | -- | -- |
| `=` | Affectation simple | `$i = 2` |  |
| `+=` | Affectation apr√®s addition | `$i += 2` | `$i = $i + 2` |
| `-=` | Affectation apr√®s soustraction | `$i -= 2` | `$i = $i - 2` |
| `*=` | Affectation apr√®s multiplication | `$i *= 2` | `$i = $i * 2` |
| `/=` | Affectation apr√®s division | `$i /= 2` | `$i = $i / 2` |
| `%=` | Affectation apr√®s modulo | `$i %= 2` | `$i = $i % 2` |
| `++` | Incr√©mentation | `$i++` | `$i = $i + 1` |
| `--` | D√©cr√©mentation | `$i--` | `$i = $i - 1` |


## Collections et tableaux

Les commandes PowerShell retournent souvent non pas un objet, mais plusieurs objets dans le pipeline. Par exemple, il est fr√©quent que la commande `Get-ChildItem` retourne plus d'un objet, car il y a g√©n√©ralement plusieurs fichiers et dossiers dans un dossier.

![image](./assets/r02/r03_04a.png)


### Compter les objets d'une collection

On peut conna√Ætre le nombre d'√©l√©ments retourn√©s par une commande √† l'aide de la commande `Measure-Object`.

![image](./assets/r02/r03_04b.png)

Et comme plusieurs objets mis ensemble constituent une collection d'objets, et que cette collection est √©galement un objet, on peut aussi lire l'attribut `.Length` de cette collection.

![image](./assets/r02/r03_04c.png)

### Acc√©der √† un √©l√©ment pr√©cis

Une collection dans PowerShell est une liste d'objet, qu'on appelle aussi Tableau ou Array, et qui est compos√© de plusieurs valeurs dans un ordre pr√©cis. Chaque √©l√©ment occupe une position: le premier a la position 0, le deuxi√®me 1, et ainsi de suite. Ces nombre s'appelle un indice (index). On peut obtenir l'√©l√©ment correspondant en sp√©cifiant l'indice voulu entre crochets.

![image](./assets/r02/r03_04d.png)

### Cr√©er un tableau

Un tableau vide est cr√©√© avec la formule `@()`. Pour initialiser un nouveau tableau, donc, il suffit d'affecter le tableau vide √† une variable. On peut ensuit lui ajouter des √©l√©ments, avec un op√©rateur d'affectation.

![image](./assets/r02/r03_05a.png)

Un tableau peut comprendre plusieurs √©l√©ments de types diff√©rents, mais habituellement, on il est plus logique d'y retrouver des √©l√©ments du m√™me type.

On peut affecter directement des valeurs √† la cr√©ation d'un tableau. Dans ce cas, on n'est pas oblig√© de respecter la syntaxe `@(‚Ä¶)`; elle est implicite. 

![image](./assets/r02/r03_05b.png)

On peut aussi utiliser un raccourci pour cr√©er rapidement un tableau d'entiers.

![image](./assets/r02/r03_05c.png)


### S√©lectionner des √©l√©ments

Lorsqu'on a un tableau d'objet qui circule dans le pipeline, on peut vouloir manipuler ce tableau pour en ressortir certains √©l√©ments et pas d'autres.

#### S√©lection des indices

![image](./assets/r02/r03_06a.png)

#### S√©lection conditionnelle

![image](./assets/r02/r03_06b.png)

Ou‚Ä¶

![image](./assets/r02/r03_06c.png)

![image](./assets/r02/r03_06d.png)

![image](./assets/r02/r03_06e.png)


### Op√©rations sur un tableau

#### Op√©rateur -Contains

Pour tester si un tableau contient une valeur sp√©cifique, on peut utiliser l'op√©rateur `-Contains`.

![image](./assets/r02/r03_07a.png)

#### Concat√©nation

Donne tous les objets des deux collections (fusionne deux collections bout √† bout)

![image](./assets/r02/r03_07b.png)

#### Union

Donne tous les objets de deux collections, mais sans doublons.

![image](./assets/r02/r03_07c.png)

#### Intersection

Donne tous les objets qui ont √† la fois dans deux collections

![image](./assets/r02/r03_07d.png)

#### Diff√©rence

Retourne une collection moins tous les √©l√©ments semblables d'une deuxi√®me collection

![image](./assets/r02/r03_07e.png)

#### Tri

On peut trier une collection √† l'aide de la commande `Sort-Object`, par ordre croissant ou d√©croissant.

![image](./assets/r02/r03_07f.png)

Par d√©faut, le tri s'effectue sur le nom d'affichage, mais il est possible de sp√©cifier sur quelle propri√©t√© devra s'effectuer le tri.

![image](./assets/r02/r03_07g.png)














