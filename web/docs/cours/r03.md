---
title: R03 - Dictionnaires et scripts
slug: "03"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 3 - Dictionnaires et scripts

:::note R√©sum√© de la s√©ance

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Rappel du cours pr√©c√©dent
1. Scripts
    1. Strat√©gies d'ex√©cution et mesures de s√©curit√©
    1. Encodage (UTF-8 avec ou sans BOM)
    1. Visual Studio Code
    1. Structures de contr√¥le
1. Structures de contr√¥le
    1. Conditions (if, switch)
    1. Boucles (for, while, do, foreach, Foreach-Object)
1. Structures de donn√©es en dictionnaire
    1. Objets [Hashtable]
    1. Objets [PSCustomObject]
    1. Splatting
1. Bonnes pratiques

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

- Exercice 04 sur OneNote
- N'oubliez pas le devoir #1 √† remettre au plus tard dimanche le 10 septembre √† 23h59.

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::

## Scripts

Comme la plupart des langages de script, PowerShell est un langage interpr√©t√©. Un fichier de script est donc un fichier texte standard contenant des lignes de commandes PowerShell. Lorsqu'on le passe dans l'interpr√©teur PowerShell, celui-ci ex√©cute son contenu comme si chaque ligne du fichier √©tait saisie une apr√®s l'autre dans la console. L'interpr√©teur reconnait le format d'un script PowerShell gr√¢ce √† l'extension de fichier `.PS1`.

Plusieurs conditions doivent √™tre respect√©es afin d'ex√©cuter un script PowerShell avec succ√®s, que ce soit pour des raisons de s√©curit√© ou de compatibilit√©.

### Strat√©gie d'ex√©cution (*ExecutionPolicy*)

Par d√©faut, sous Windows 10/11, l'ex√©cution de scripts PowerShell est interdite pour des raisons de s√©curit√©. Seuls les scripts qui poss√®dent une signature num√©rique *AuthentiCode* sont autoris√©s. Les syst√®mes d'exploitation Windows Server, quant √† eux, ne bloquent l'ex√©cution de scripts que lorsqu'ils proviennent d'Internet. Dans tous les cas, il est possible de modifier ce comportement. Ces r√®gles sont d√©finies dans la **strat√©gie d'ex√©cution** (*execution policy*).

Il existe plusieurs niveaux de strat√©gies d'ex√©cution, et chacun d√©termine dans quelles condition le syst√®me d'exploitation peut refuser ou permettre l'ex√©cution d'un script PowerShell. 

| Strat√©gie d'ex√©cution | Caract√©ristiques |
| -- | -- |
| `Restricted` | Lorsque la strat√©gie d'ex√©cution est Restricted, seuls les scripts portant une signature num√©rique (authenticode) sont approuv√©s et peuvent √™tre ex√©cut√©s par l'interpr√©teur PowerShell. C'est la strat√©gie par d√©faut sur les clients Windows. |
| `RemoteSigned` | Les scripts provenant d'un m√©dium de stockage local, de l'intranet ou d'un site Internet de confiance sont autoris√©s. Ceux provenant d'Internet seront bloqu√©s √† moins de porter une signature num√©rique ou d'√™tre d√©bloqu√©s avec la commande Unblock-File. C'est la strat√©gie par d√©faut sur les serveurs Windows, et la strat√©gie recommand√©e sur les clients Windows faisant partie d'un domaine ou utilis√©s pour d√©velopper des scripts. |
| `AllSigned` | Cette strat√©gie oblige tous les scripts √† poss√©der une signature num√©rique. |
| `Unrestricted` | Les scripts non sign√©s provenant d'Internet peuvent √™tre ex√©cut√©s, mais en demandant la permission √† l'utilisateur. |
| `Bypass` | Cette strat√©gie est la plus permissive: tous les scripts peuvent s'ex√©cuter sans restriction. |

Pour conna√Ætre la strat√©gie en vigueur, on peut lancer la commande `Get-ExecutionPolicy`.

![image](./assets/r03/r05_01a.png)

Pour d√©finir la strat√©gie, c'est la commande `Set-ExecutionPolicy` qu'il faut utiliser. 

![image](./assets/r03/r05_01b.png)

Normalement, il faut √™tre administrateur de sa machine pour pouvoir d√©finir la strat√©gie d'ex√©cution (la commande doit √™tre lanc√©e avec des privil√®ges **√©lev√©s**). Mais il est possible de la d√©finir dans le contexte de l'utilisateur local avec l'argument `-Scope CurrentUser`.

![image](./assets/r03/r05_01c.png)

Lorsque plusieurs strat√©gies sont d√©finies, Windows utilise un ordre de priorit√© (appel√© precedence) pour d√©terminer la valeur r√©sultante. On peut voir la liste des strat√©gies d'ex√©cution selon leur niveau de priorit√© en lan√ßant la commande Get-ExecutionPolicy -List; la valeur effective est celle qui est retourn√©e par Get-ExecutionPolicy sans sp√©cifier d'argument.

![image](./assets/r03/r05_01d.png)

Les niveaux de priorit√© (ou Scope) sont les suivants:

| Scope | Description |
| -- | -- |
| `MachinePolicy` | Configuration de la strat√©gie au moyen de GPO machine, dans Active Directory. Les GPO machine ont une priorit√© absolue. |
| `UserPolicy` | Configuration de la strat√©gie au moyen de GPO utilisateur, dans Active Directory. |
| `Process` | Configuration de la strat√©gie effective pour le processus seulement. On d√©finit cette strat√©gie lors de l'appel du programme powershell.exe |
| `CurrentUser` | Configuration de la strat√©gie par d√©faut pour l'utilisateur courant. Cette strat√©gie peut √™tre modifi√©e sans disposer de droits d'administration. |
| `LocalMachine` | Configuration de la strat√©gie par d√©faut pour l'ordinateur local. Cette strat√©gie peut √™tre modifi√©e seulement par un administrateur de la machine. C'est le niveau le moins prioritaire. |

Lorsque l'un ou l'autre des scopes est non d√©fini (undefined), cela signifie que ce niveau est ignor√©. La strat√©gie effective sera la plus haute dans la liste de priorit√© parmi toutes celles qui ne sont pas "undefined".

:::tip

Lorsqu'on d√©marre une session PowerShell √† l'aide du programme powershell.exe, on peut sp√©cifier une ExecutionPolicy diff√©rente de la configuration du syst√®me, qui ne vaut que pour cette instance pr√©cise de PowerShell. Pour ce faire, on doit indiquer la strat√©gie voulue √† l'aide du param√®tre -ExecutionPolicy. Cela aura pour effet de d√©finir le scope Process, dont la priorit√© d√©passe celle des pr√©f√©rences machine et utilisateur. Seules les GPO ont une priorit√© sup√©rieure.

![image](./assets/r03/r05_01e.png)

:::


### Fichiers bloqu√©s

Lorsqu'on t√©l√©charge un fichier sur Internet, Windows appose automatiquement une marque sur le fichier. Cette marque, appel√©e Zone Identifier, est conserv√©e dans un champ alternatif (Alternate Data Stream), une structure dans le syst√®me de fichiers NTFS permettant de stocker des m√©tadonn√©es. Si vous t√©l√©chargez un fichier script sur Internet et que vous le savez s√©curitaire (par exemple, votre script que vous t√©l√©chargez sur OneDrive), vous pouvez le d√©bloquer par l'interface graphique dans ses propri√©t√©s, ou encore √† l'aide de la commande `Unblock-File`.

Un fichier ainsi bloqu√© sera impossible √† ex√©cuter si la strat√©gie d'ex√©cution est AllSigned ou RemoteSigned, √† moins d'avoir √©t√© d√ªment sign√© au moyen d'un certificat Authenticode en r√®gle.

![image](./assets/r03/r05_02a.png)

![image](./assets/r03/r05_02b.png)


### Encodage

PowerShell 5.1 est assez capricieux sur l'encodage des caract√®res, surtout lorsqu'il est question de caract√®res accentu√©s. Assurez-vous de sauvegarder les fichiers en format UTF8 avec BOM.

![image](./assets/r03/r05_03a.png)

Si l'encodage n'est pas ad√©quat, vous pourrez vous retrouver avec des caract√®res bizarres au lieu des lettres accentu√©es.

![image](./assets/r03/r05_03b.png)


### Ex√©cution d'un script

Il y a plusieurs mani√®res d'ex√©cuter un script. Voici les principales:

#### Ex√©cution par l'interface graphique

Vous pouvez lancer un script directement √† partir de l'explorateur de fichiers sous Windows. Vous pourriez √™tre tent√© de double-cliquer sur le fichier de script, mais vous ne feriez qu'ouvrir le fichier dans le bloc-notes. Il faut plut√¥t cliquer avec le bouton de droite dans l'explorateur, puis s√©lectionner Ex√©cuter avec PowerShell.

Cette m√©thode est certes intuitives, mais pr√©sente quelques inconv√©nients:
- Vous ne pouvez pas d√©marrer le script en tant qu'administrateur.
- La fen√™tre se ferme toute seule une fois le script termin√©, ce qui ne vous laisse pas le temps de voir s'il y a eu une erreur lors de l'ex√©cution.
- Il est impossible de sp√©cifier des arguments √† la ligne de commande.

![image](./assets/r03/r05_04a.png)


#### Ex√©cution par la console PowerShell

C'est la m√©thode la plus utile, car elle permet de sp√©cifier des arguments et de voir le r√©sultat du script √† la console.

Il suffit de d√©marrer une console PowerShell (en lan√ßant le programme powershell.exe, par le menu d√©marrer, par le menu Win+X, etc.) puis ex√©cuter un fichier .ps1. Si le chemin du fichier est relatif, vous devez d√©marrer le chemin par `.\` (comme sous Linux).

![image](./assets/r03/r05_04b.png)

Si le script ne peut s'ex√©cuter, lisez le message d'erreur. S'il est mention de la strat√©gie d'ex√©cution (*ExecutionPolicy*), assurez-vous que votre strat√©gie soit d√©finie √† RemoteSigned ou plus permissif, et que votre fichier n'est pas bloqu√© (`Unblock-File`).


#### Ex√©cution par l'invite de commande (cmd)

On peut lancer un script PowerShell √† partir d'une commande classique, en lan√ßant le programme `powershell.exe` avec l'argument `-file`.

![image](./assets/r03/r05_04c.png)

Il est aussi possible de contourner la strat√©gie d'ex√©cution, en sp√©cifiant l'argument `-ExecutionPolicy`.

![image](./assets/r03/r05_04d.png)


### Variables *$PSScriptRoot* et *$PSCommandPath*

Lorsque du code PowerShell est ex√©cut√© √† travers un script, il est possible de r√©cup√©rer de l'information sur ce fichier.

Vous pouvez conna√Ætre le chemin complet du script en interrogeant la variable `$PSCommandPath`.

![image](./assets/r03/script_pscommandpath.png)

Vous pouvez aussi conna√Ætre le chemin complet du r√©pertoire dans lequel votre fichier de script est situ√©, en interrogeant la variable `$PSScriptRoot`

![image](./assets/r03/script_psscriptroot.png)

Notez que ces variables n'existent que pendant l'ex√©cution d'un script. Elles sont vides sinon.

![image](./assets/r03/script_varconsole.png)


### Le caract√®re *BackTick*

Voici quelques caract√®res sp√©ciaux qui doivent √™tre sp√©cifi√©s √† l'aide du caract√®re d'√©chappement, le *backtick*, qui ressemble √† un accent grave sans la lettre qui l'accompagne.

| Caract√®re | Hex. | D√©c. | Description |
| -- | -- | -- | -- |
| \`r | 0x0D | 13 | Retour de chariot (carriage-return) |
| \`n | 0x0A | 10 | Saut de ligne (line-feed) - changement de ligne sur les syst√®mes UNIX
| \`r\`n | 0x0D, 0x0A | 13, 10 | CRLF (retour de chariot + saut de ligne) - changement de ligne sur Windows |
| \`t | 0x09 | 9 | Caract√®re de tabulation |
| \`f | 0x0C | 12 | Caract√®re de saut de page (pour les imprimantes) |


Le caract√®re *Backtick* agit √©galement de caract√®re d'√©chappement, c'est-√†-dire que tout caract√®re qui le suit dans une cha√Æne de caract√®res est interpr√©t√© comme un caract√®re normal, sans √©gard √† son utilit√© normale.

| Caract√®re | Hex. | D√©c. | Description |
| -- | -- | -- | -- |
| \`\` | 0x60 | 96 | Le caract√®re *backtick* (accent grave) |
| \`" | 0x22 | 34 | Le guillemet double |
| \`' | 0x27 | 39 | Le guillemet simple |
| \`# | 0x23 | 35 | Le carr√© (pour marquer les commentaires) |
| \`$ | 0x24 | 36 | Le signe de piastre (pour marquer les variables) |

Finalement, le caract√®re *Backtick* peut aussi √™tre utilis√© pour couper une ligne en deux.

```powershell
Copy-Item -Path "C:\Minou\miaou.txt" `
          -Destination "C:\Pitou\wouf.txt" `
          -Force
```


:::tip

Ce caract√®re est difficile √† trouver sur certains clavier, dont celui qui est le plus commun au Qu√©bec. Sur ce clavier (celui o√π on presse sur la touche de l'accent grave puis sur celle de la lettre), il suffit de faire un "espace accent grave".

![image](./assets/r03/r05_05a.png)

:::


## Visual Studio Code

Les scripts PowerShell sont des fichiers texte, il est donc parfaitement possible de les d√©velopper √† l'aide de n'importe quel √©diteur de texte (le bloc-notes, Notepad++, Nano, etc.)

Celui que nous utiliserons dans ce cours est [**Visual Studio Code**](https://code.visualstudio.com/), un environnement int√©gr√© de d√©veloppement (IDE) gratuit en *open-source* d√©velopp√© par Microsoft. Il poss√®de de nombreuses fonctionnalit√©s pour aider les programmeurs √† √©crire, g√©rer et tester leur code. Il supporte de nombreux langages de programmation, dont PowerShell. C'est cet outil de d√©veloppement que vous utiliserez tout au long de ce cours.

![image](./assets/r03/r05_06a.png)


:::info
Il existe d'autres logiciels que vous √™tes libres d'explorer. Vous connaissez peut-√™tre [**Windows PowerShell ISE**](https://learn.microsoft.com/fr-ca/powershell/scripting/windows-powershell/ise/introducing-the-windows-powershell-ise?view=powershell-5.1), qui est inclus dans Windows. Bien qu'il ne soit pas aussi avanc√© que VS Code sur plusieurs aspects, il peut s'av√©rer utile lorsque vous devez d√©velopper ou modifier un script √† la vol√©e sur un serveur, sans vouloir installer un logiciel. Vous pouvez le d√©marrer par le menu D√©marrer, ou encore en lan√ßant la commande `PowerShell_ISE.exe`. Notez cependant que Windows PowerShell ISE ne supporte pas les versions de PowerShell plus r√©centes; son support se termine √† la version 5.1.  Microsoft a cess√© d'am√©liorer ce logiciel au profit de Visual Studio Code, qui est d√©sormais consid√©r√© par Microsoft comme l'environnement de d√©veloppement "officiel" pour PowerShell.

Parmi les autres environnements populaires, il y a [**Idera PowerShell Plus**](https://www.idera.com/productssolutions/freetools/powershellplus/), principalement orient√© vers les administrateurs de bases de donn√©es, et [**SAPIEN PowerShell Studio**](https://www.sapien.com/software/powershell_studio), qui se d√©marque par de nombreuses fonctionnalit√©s dont un √©diteur d'interfaces graphiques, un compilateur int√©gr√©, et plusieurs acc√©l√©rateurs, mais qui co√ªte assez cher (250$ US par ann√©e ou 25$ US par mois).
:::

### Espace de travail (*workspace*)

Il est id√©al de travailler dans VS Code en y ouvrant un dossier. Vous pouvez le faire soit en cliquant sur Ouvrir le dossier dans l'interface de VS Code, soit 

![image](./assets/r03/r05_06b.png)

Dans le panneau de gauche, vous pouvez voir tous vos fichiers et dossiers et les ouvrir dans les onglets. Vous pouvez-m√™me ouvrir plusieurs fichiers c√¥te √† c√¥te.

![image](./assets/r03/r05_06c.png)


### Palette de commandes

Vous pouvez ouvrir la palette de commandes en appuyant sur la touche F1 ou Ctrl+Maj+P. Vous pouvez rechercher des fonctionnalit√©s et des actions.

![image](./assets/r03/r05_06d.png)


### Terminal int√©gr√© et ex√©cution PowerShell

Lorsque vous avez un fichier .PS1 ouvert, le terminal int√©gr√© PowerShell d√©marre automatiquement.

Vous pouvez utiliser ce terminal de la m√™me mani√®re qu'une invite PowerShell standard.

Si vous s√©lectionnez une partie de votre code et appuyez sur la touche F8, ce code sera automatiquement pass√© dans le terminal.

![image](./assets/r03/r05_06e.png)


Pour lancer le script facilement, appuyez simplement sur F5. Cela ex√©cute le script dans le terminal int√©gr√© en mode d√©bogage.

![image](./assets/r03/r05_06f.png)


Pour automatiquement s√©lectionner toutes les occurrences d'un m√™me mot (par exemple, pour changer le nom d'une variable partout √† la fois), s√©lectionner le texte √† remplacer puis faites Ctrl+F2 (ou clic droit, Modifier toutes les occurrences).

![image](./assets/r03/r05_06g.png)


### Installation

Dans les laboratoires du Coll√®ge, VS Code est d√©j√† install√© et configur√© pour le d√©veloppement de scripts en PowerShell. Si vous souhaitez l'utiliser sur votre ordinateur personnel ou sur une machine virtuelle, suivez ces directives.

T√©l√©chargez l'application sur le site officiel (https://code.visualstudio.com/). Il en existe plusieurs variantes:
- Stable build: c'est la version la plus stable, et celle que vous devriez utiliser.
- Insider build: c'est une pr√©version pour tester les nouvelles fonctionnalit√©s. Il peut y avoir des bogues.

Choisissez l'installateur qui convient √† vos besoin.

- User Installer: c'est l'option par d√©faut. VS Code s'installe dans votre profil utilisateur, donc vous n'avez pas besoin de droits d'administration. Il sera install√© seulement pour vous, pas pour les autres utilisateurs.
- System Installer: pour installer VS Code pour tous les utilisateurs du syst√®me. √áa prend des droits d'administration.

![image](./assets/r03/r05_06h.png)

Puis, lancez l'installateur et r√©pondez aux questions. Assurez-vous de d√©poser une ic√¥ne sur le bureau et d'enregistrer les actions au menu contextuel.

![image](./assets/r03/r05_06i.png)


### Configuration

Installez mon pack d'extensions. Cela installera tout ce qu'il vous faut pour d√©velopper en PowerShell!

![image](./assets/r03/r05_06j.png)

Une fois termin√©, vous devez red√©marrer VS Code. Vous constaterez qu'il est maintenant en fran√ßais.

Je vous recommande d'activer le th√®me de couleur "PowerShell ISE", car il est optimis√© pour PowerShell. Mais s'il ne vous plait pas, vous pouvez en essayer d'autres, et m√™me en installer de nouveaux.

![image](./assets/r03/r05_06k.png)

Ajustez les param√®tres de VS Code. Vous pouvez explorer les param√®tres disponibles, mais voici minimalement ceux que je vous recommande:

Copiez-collez ceci dans le fichier settings.json, et sauvegardez-le.

```json
{
    "powershell.codeFormatting.preset": "Stroustrup",
    "powershell.codeFormatting.trimWhitespaceAroundPipe": true,
    "powershell.codeFormatting.useCorrectCasing": true,
    "powershell.integratedConsole.focusConsoleOnExecute": false,

    "[powershell]": {
        "files.encoding": "utf8bom",
        "editor.suggestSelection": "first",
        "editor.tabCompletion": "on",
        "editor.codeLens": false
    },

    "workbench.colorTheme": "PowerShell ISE"   
}
```


## Les structures de contr√¥le

A priori, les instructions contenues dans un fichier de script dont ex√©cut√©es dans un ordre s√©quentiel, que l'on appelle le **flot de contr√¥le** (*control flow*). Les structures de contr√¥le sont des instructions qui permettent de d√©vier le flot de contr√¥le et ainsi rendre le programme dynamique.

Il existe quatre grands types de structures de contr√¥le:
- La **s√©lection**, qui permet d'ignorer des instructions sous certaines conditions;
- La **r√©p√©tition**, qui permet de revenir en arri√®re et r√©p√©ter une instruction ou un ensemble d'instructions plusieurs fois en boucle;
- Le **sous-programme**, qui permet d'interrompre le cours normal du programme et d'ex√©cuter du code d√©clar√© ailleurs;
- Le **d√©placement**, qui permet de se "d√©placer" ailleurs dans le code. Ce type de structure de contr√¥le est jug√©e d√©su√®te dans de nombreux langages de programmation, y compris PowerShell.


### Les structures de s√©lection

#### S√©lection √† une branche (*If*)

La structure `If` permet une s√©lection de code conditionnelle. Dans sa variante √† une branche, on pose une condition bool√©enne; si la condition est vraie, le code sp√©cifi√© entre accolades sera ex√©cut√©, autrement il sera ignor√©.

<Tabs>
<TabItem value="code" label="Code">

```powershell
[int] $nombre = Read-Host "Entrez un nombre de 1 √† 3..."

if ($nombre -eq 1) {
    Write-Host "Un!"
}

Write-Host "Fini!"

```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\If.ps1" result="
Entrez un nombre de 1 √† 3...: 1
Un!
Fini!" />

</TabItem>
</Tabs>


#### S√©lection √† deux branches (*If...Else*)

Dans sa variable √† deux branche, on d√©clare un deuxi√®me bloc de code √† l'aide de l'instruction `else`. C'est le code qui sera ex√©cut√© uniquement si la condition est √©valu√©e `false`.


<Tabs>
<TabItem value="code" label="Code">

```powershell
[int] $nombre = Read-Host "Entrez un nombre de 1 √† 3..."

if ($nombre -eq 1) {
    Write-Host "Un!"
}
else {
    Write-Host "Autre!"
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\IfElse.ps1" result="
Entrez un nombre de 1 √† 3...: 2
Autre!
Fini!" />

</TabItem>
</Tabs>



#### S√©lection imbriqu√©e (*If...ElseIf...Else*)

On peut imbriquer autant de blocs `ElseIf` que l'on veut entre le `If` et le `Else`. Chaque bloc `ElseIf` pose une condition. Si la condition sp√©cifi√©e dans le bloc `If` ou dans le bloc `ElseIf` pr√©c√©dent est fausse, alors le bloc suivant tente son ex√©cution. En dernier recours, le bloc `Else` est ex√©cut√© uniquement lorsque toutes les conditions des blocs `If` et `ElseIf` n'ont pas √©t√© respect√©es. Il est important de noter que d√®s qu'une condition est vraie, les blocs `ElseIf` suivants ne seront pas ex√©cut√©s, m√™me si leur condition est vraie; seulement le premier √† √©valuer vrai sera ex√©cut√©.

<Tabs>
<TabItem value="code" label="Code">

```powershell
[int] $nombre = Read-Host "Entrez un nombre de 1 √† 3..."

if ($nombre -eq 1) {
    Write-Host "Un!"
}
elseif ($nombre -eq 2) {
    Write-Host "Deux!"
}
else { 
    Write-Host "Autre!" 
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\IfElseifElse.ps1" result="
Entrez un nombre de 1 √† 3...: 2
Deux!
Fini!" />

</TabItem>
</Tabs>


#### S√©lection √† *n* branches (*switch*)

L'instruction `Switch` est une alternative √† `If`. Elle est pratique lorsqu'on a de nombreuses valeur √† tester et que la condition est simple, comme les options d'un menu par exemple.

Optionnellement, on peut sp√©cifier un cas Default, qui est s√©lectionn√© si aucun autre cas n'est √©valu√© vrai.

<Tabs>
<TabItem value="code" label="Code">

```powershell
[int] $nombre = Read-Host "Entrez un nombre de 1 √† 3..."

switch ($nombre) {
    1   { Write-Host "Un!"      }
    2   { Write-Host "Deux!"    }
    3   { Write-Host "Trois!"   }
    Default { 
        Write-Host "Autre!" 
    }
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\Switch.ps1" result="
Entrez un nombre de 1 √† 3...: 2
Deux!
Fini!" />

</TabItem>
</Tabs>


#### Exemples de s√©lection

##### Tester l'existence d'un r√©pertoire

```powershell
if (Test-Path -Path "C:\Minou" -PathType Container) {
    Write-Host "Le r√©pertoire existe!"
}
else {
    Write-Host "Le r√©pertoire n'existe pas!"
}
```

##### Tester si une collection est vide

```powershell
$chemin = Read-Host -Prompt "Entrez un chemin de r√©pertoire"

$documents = Get-ChildItem -Path $chemin | Where-Object { $_.Name -like "*.docx" }

if ($documents.count -gt 0) {
    Write-Host "Il y a $($documents.count) documents."
}
else {
    Write-Host "Il n'y a aucun document."
}
```


##### Tester si un objet est nul (cas particulier)

```powershell
$service = Get-Service "Nexistepas"

if ($null -ne $service) {
    Write-Host "Le service est: $($service.status)."
}
else {
    Write-Host "Service introuvable."
}
```


### Structures de r√©p√©tition (boucles)

#### Boucle *While*

Dans une boucle *While*, le code entre accolade est ex√©cut√© si la condition est vraie. Le code est r√©ex√©cut√© encore et encore tant que l‚Äô√©valuation de la condition soit toujours vraie. Lorsque la condition devient fausse, la boucle est interrompue et le code continue son ex√©cution normale.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$i = 0

while ($i -le 3) {
    Write-Host $i
    $i++
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\While.ps1" result="
0
1
2
3
Fini!" />

</TabItem>
</Tabs>


#### Boucle *Do ... While*

Dans une boucle *Do ... While*, le code entre accolades apr√®s l‚Äôinstruction do est ex√©cut√©.
√Ä la fin du bloc de code, si la condition est respect√©e, ce code est r√©ex√©cut√©.
Lorsque la condition devient fausse, la boucle est interrompue et le code continue son ex√©cution normale.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$i = 0

do {
    Write-Host $i
    $i++
}
while ($i -le 3)

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\DoWhile.ps1" result="
0
1
2
3
Fini!" />

</TabItem>
</Tabs>

:::warn

La diff√©rence entre les boucles *While* et *Do...While* est subtile mais importante. Dans le cas de la boucle *While*, la condition est √©valu√©e **avant** le premier tour de boucle. Donc il est possible que le code de la boucle ne soit ex√©cut√© aucune fois. √Ä l'inverse, la condition de la boucle *Do...While* est √©valu√©e apr√®s le premier tour; on a donc la certitude que le code de la boucle sera ex√©cut√© au moins une fois, m√™me si la condition initiale ne le permettrait pas. Choisissez donc le type de boucle qui r√©pond le mieux √† votre besoin.

:::


#### Boucle *Do ... Until*

Une boucle *Do ... Until* fonctionne de la m√™me mani√®re qu'une boucle *Do ... While*, √† la diff√©rence qu'on sp√©cifie une condition de sortie plut√¥t qu'une condition de r√©entr√©e. La condition sp√©cifi√©e √† la clause Until repr√©sente une condition qui, si elle est vraie, entra√Ænera la fin de la boucle. Autrement dit, c'est l'inverse d'un *Do ... While*.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$i = 0

do {
    Write-Host $i
    $i++
}
until ($i -gt 3)

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\DoUntil.ps1" result="
0
1
2
3
Fini!" />

</TabItem>
</Tabs>


#### Boucle infinie

Une boucle infinie survient lorsque la condition de bouclage est toujours vraie. En temps normal, on cherche √† √©viter ce sc√©nario, sauf dans des cas tr√®s sp√©cifiques. 

Il faut toujours pr√©voir une fa√ßon de sortir de la boucle. On peut sortir de la boucle avec l‚Äôinstruction `break`.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$i = 0
while ($true) {
    Write-Host $i

    if ($i -gt 3) {
        break
    }
    $i++
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\WhileTrue.ps1" result="
0
1
2
3
Fini!" />

</TabItem>
</Tabs>


#### Boucle compteur (*For*)

Une boucle compteur est utile lorsqu‚Äôon souhaite r√©p√©ter le code un certain nombre de fois. 

La syntaxe comprend trois parties:
- L‚Äôaction √† ex√©cuter au d√©but de la boucle (une seule fois)
- La condition de bouclage (si elle est vraie, on entre dans la boucle)
- L‚Äôaction √† ex√©cuter apr√®s chaque tour de boucle

La boucle *for* utilise typiquement une variable contenant un nombre entier comme compteur, bien que ce type de boucle puisse √™tre utilis√© de mani√®re diff√©rente. 


<Tabs>
<TabItem value="code" label="Code">

```powershell
for ($i = 0; $i -le 3; $i++) {
    for ($j = 0; $j -le 2; $j++) {
        Write-Host "$i.$j"
    }
}
Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\For.ps1" result="
0.0
0.1
0.2
1.0
1.1
1.2
2.0
2.1
2.2
3.0
3.1
3.2
Fini!" />

</TabItem>
</Tabs>

:::tip

Les variables compteur sont typiquement nomm√©es `$i`. Normalement, les variables devraient avoir un nom plus significatif, mais par convention il est acceptable de nommer les compteurs avec une simple lettre.

Si deux boucles ou plus sont imbriqu√©es les unes dans les autres, on peut utiliser les variables `$j`, `$k`, et ainsi de suite.

:::


#### Boucle de collection (*ForEach*)

Une boucle de collection est utile lorsqu‚Äôon a du code √† ex√©cuter pour chaque √©l√©ment d‚Äôune collection.

La syntaxe comprend deux parties:
- L‚Äôobjet courant, **une variable** qui repr√©sente un √©l√©ment. Il sera diff√©rent √† chaque tour de boucle.
- La **collection**, qui sera trait√©e un √©l√©ment √† la fois, √† chaque tour de boucle.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$collection = 0..3

foreach ($element in $collection) {
    Write-Host $element
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\ForEach.ps1" result="
0
1
2
3
Fini!" />
</TabItem>
</Tabs>


#### Boucle de pipeline (*ForEach-Object*)

Au lieu de la boucle ForEach, on peut utiliser le cmdlet `ForEach-Object`. L‚Äôeffet est le m√™me, mais fait usage du pipeline PowerShell. 

L‚Äôobjet courant est repr√©sent√© par la variable pipeline `$_` (ou alternativement, `$PSItem`).

<Tabs>
<TabItem value="code" label="Code">

```powershell
$collection = 0..3

$collection | ForEach-Object {
    Write-Host $_
}

Write-Host "Fini!"
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\Scripts" command=".\ForEach-Object.ps1" result="
0
1
2
3
Fini!" />
</TabItem>
</Tabs>


### √âchappement (*break*)

Pour quitter "de force" une structure de contr√¥le, on peut utiliser l'instruction `break`.

```powershell
While ($true) {

    $reponse = Read-Host -Prompt "Voulez-vous quitter? (O/N)"

    if ($reponse -eq "O") {
        Write-Host "kbye"
        break
    } 

    Write-Host "Attendons un peu..."
    Start-Sleep -Seconds 2

}
```

:::tip

√Ä tout moment durant l'ex√©cution d'un script, lorsqu'on est prisonnier d'une boucle infini, on peut appuyer sur `CTRL+C` dans la console pour mettre fin √† l'ex√©cution du script instantan√©ment.

:::


## Dictionnaires

Un **dictionnaire**, aussi appel√© *tableau associatif*, est une structure de donn√©es qui se caract√©rise par une liste de correspondance entre une cl√© et une valeur, qui repr√©sentent des propri√©t√©s. La cl√© repr√©sente le nom de la propri√©t√©, et la valeur, son contenu. Contrairement aux tableaux, l'ordre des √©l√©ments n'a pas d'importance, justement parce qu'on peut y acc√©der librement en utilisant la cl√©.

Dans PowerShell, on travaille avec deux types de dictionnaires, des *HashTable*, et des *PSCustomObject*.


### Tables de hachage (*HashTable*)

La table de hachage (*HashTable*) est la forme la plus rudimentaire d'un dictionnaire en PowerShell.

Voici un exemple de cr√©ation d'un objet de type *HashTable*:

<Tabs>
<TabItem value="code" label="Code">

```powershell
$minou = @{ 
    Nom = "Garfield"
    Espece = "Felis catus"
    Passion = "Manger"
}
```
</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\" command="$minou" result="
Name            Value
----            -----
Passion         Manger
Nom             Garfield
Espece          Felis catus"/>

</TabItem>
</Tabs>

Chaque cl√© de cet objet est le nom d'une de ses propri√©t√©s. On peut donc acc√©der √† une propri√©t√© avec la notation ".".

<PowerShellWindow workdir="C:\" command="$minou.Passion" result="
Manger
">

</PowerShellWindow>


:::tip
Pour cr√©er un objet *hashtable* en une seule ligne, utilisez le caract√®re `;` entre les √©l√©ments.

```powershell
$minou = @{ Nom = "Garfield" ; Espece = "Felis catus" ; Passion = "Manger" }
```
:::

### *Hashtables* tri√©es

G√©n√©ralement, on n'a pas besoin qu'un dictionnaire soit tri√©, car il sert √† acc√©der √† ses propri√©t√©s √† la demande, et non de mani√®re s√©quentielle. Mais si, pour une quelconque raison, vous souhaitiez tout de m√™me pr√©server l'ordre des √©l√©ments du dictionnaire, pour pouvez d√©clarer l'acc√©l√©rateur `[ordered]`.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$minou = [ordered]@{ 
    Nom = "Garfield"
    Espece = "Felis catus"
    Passion = "Manger"
}
```
</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\" command="$minou" result="
Name            Value
----            -----
Nom             Garfield
Espece          Felis catus
Passion         Manger"/>



<PowerShellWindow>
```
Name            Value
----            -----
Nom             Garfield
Espece          Felis catus
Passion         Manger"/>
```
</PowerShellWindow>

</TabItem>
</Tabs>

### Comportement du *HashTable*

Un *HashTable* n'a pas vraiment le m√™me comportement qu'un objet PowerShell. Ce type d'objet est en fait une structure de donn√©es compos√©e de cl√©s et de valeurs, comme un dictionnaire.

L'exemple suivant montre un tableau de *HashTable*, le r√©sultat que nous nous attendrions d'avoir lors de l'affichage et le r√©sultat r√©el.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$minous = @(
    @{
        Nom = "Garfield"
        Espece = "Felis catus"
        Passion = "Manger"
    },
    @{
        Nom = "Grumpy Cat"
        Espece = "Felis catus"
        Passion = "Faire la baboune"
    }
)
```

</TabItem>
<TabItem value="resultat_souhaite" label="R√©sultat souhait√©">

<PowerShellWindow workdir="C:\" command="$minou" result="
Nom           Espece         Passion
---           ------         -------
Garfield      Felis catus    Manger
Grumpy Cat    Felis catus    Faire la baboune" />

</TabItem>
<TabItem value="resultat" label="R√©sultat r√©el">

<PowerShellWindow workdir="C:\" command="$minou" result="
Name            Value
----            -----
Passion         Manger
Nom             Garfield
Espece          Felis catus
Passion         Faire la baboune
Nom             Grumpy Cat
Espece          Felis catus" />

</TabItem>
</Tabs>


### Objets personnalis√©s (*PSCustomObject*)

Pour cr√©er un objet disposant de propri√©t√©s propres mais se comportant de la m√™me mani√®re que les objets PowerShell, on utilise g√©n√©ralement le type *PSCustomObject*. Ce type repr√©sente litt√©ralement un objet PowerShell personnalit√©, duquel nous d√©finissons nous-m√™me les propri√©t√©s. Ce type d'objet est con√ßu pour imiter un objet standard compos√© de propri√©t√©s et de m√©thodes, contrairement au *HashTable* qui n'est qu'un dictionnaire servant √† associer des cl√©s √† des valeurs. C'est d'ailleurs ce type d'objet que produit la commande `Select-Object -Property`.

On cr√©e un objet PSCustomObject de la m√™me mani√®re qu'un *HashTable*, √† une diff√©rence pr√®s: on doit sp√©cifier qu'il s'agit du type PSCustomObject.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$minou = [PSCustomObject]@{ 
    Nom = "Garfield"
    Espece = "Felis catus"
    Passion = "Manger"
}
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\" command="$minou" result="
Nom           Espece         Passion
---           ------         -------
Garfield      Felis catus    Manger" />

</TabItem>
</Tabs>


### Collections de *PSCustomObject*

Contrairement aux *HashTable*, les *PSCustomObject* sont structur√©s pour faciliter leur manipulation en collection.

<Tabs>
<TabItem value="code" label="Code">

```powershell
$minous = @(
    [PSCustomObject]@{
        Nom = "Garfield"
        Espece = "Felis catus"
        Passion = "Manger"
    },
    [PSCustomObject]@{
        Nom = "Grumpy Cat"
        Espece = "Felis catus"
        Passion = "Faire la baboune"
    }
)
```

</TabItem>
<TabItem value="resultat" label="R√©sultat">

<PowerShellWindow workdir="C:\" command="$minous" result="
Nom           Espece         Passion
---           ------         -------
Garfield      Felis catus    Manger
Grumpy Cat    Felis catus    Faire la baboune" />

</TabItem>
</Tabs>


#### Modifier une propri√©t√©

Pour modifier une propri√©t√© d'un objet *PSCustomObject*, on n'a qu'√† lui affecter une nouvelle valeur.

```powershell
$minou.Passion = "Manger de la lasagne"
```

Il faut toutefois que la propri√©t√© existe dans l'objet.


#### Ajouter des propri√©t√©s

Nous avons vu plus haut comment cr√©er un objet *PSCustomObject* lorsqu'on conna√Æt toutes les propri√©t√©s de l'objet, et comment affecter une nouvelle valeur √† une propri√©t√© existante. Pour cr√©er une nouvelle propri√©t√© dans l'objet, on peut utiliser la commande `Add-Member` et lui passer en entr√©e l'objet √† modifier par le *pipeline*.

Pour une propri√©t√© simple, on n'a qu'√† cr√©er un nouveau membre de type "NoteProperty" et lui affecter un nom et une valeur.

```powershell
$minou | Add-Member -MemberType NoteProperty -Name "Couleur" -Value "Roux"
```

#### Ajouter des m√©thodes

On peut aussi ajouter d'autres types de membres, dont des m√©thodes. Contrairement aux propri√©t√©s qui retournent un objet stock√© statiquement, les m√©thodes permettent d'ex√©cuter du code. 

Le proc√©d√© est semblable √† l'ajout de propri√©t√©s, √† l'exception qu'on d√©finit un membre de type ScriptMethod et qu'on lui sp√©cifie un ScriptBlock.

```powershell
$minou | Add-Member -MemberType ScriptMethod -Name "Miauler" -Value { Write-Host "Miaou" }
```


### Splatting

Le *splatting* est une technique qui consiste √† identifier les arguments √† passer dans une commande √† l'int√©rieur d'un objet.

Il suffit de d√©finir un HashTable compos√© des arguments, dont la cl√© repr√©sente le nom de l'argument et la valeur, la valeur de l'argument. Dans le cas des arguments de type *switch*, on leur affecte la valeur `$true`. Puis, il suffit se passer cette variable √† la commande, en utilisant la forme `@Nomdelavariable`.

<Tabs>
<TabItem value="avec" label="Avec splatting">

```powershell
$splat = @{
    FilePath = "C:\Windows\Notepad.exe"
    ArgumentList = "C:\minou\allo.txt"
    WorkingDirectory = "C:\"
    PassThru = $true
    WindowStyle = "Maximized"
    Wait = $true
    Verb = "Runas"
}

Start-Process @splat
```

</TabItem>
<TabItem value="sans" label="Sans splatting">

```powershell
Start-Process -FilePath "C:\Windows\Notepad.exe" -ArgumentList "C:\minou\allo.txt" -WorkingDirectory "C:\" -PassThru -WindowStyle "Maximized" -Wait -Verb "Runas"
```

</TabItem>
</Tabs>




## Bonnes pratiques de scriptage

Certaines bonnes pratiques sont d'usage lorsqu'on d√©veloppe un script en PowerShell.

### Alias et noms de param√®tres

Dans un script, on cherche la lisibilit√© avant tout. On doit donc autant que possible **√©viter d'utiliser les alias** et leur pr√©f√©rer les vrais noms des commandes (sous leur forme Verbe-Nom).

On doit aussi √©viter les param√®tres positionnels. On peut les utiliser dans certaines commandes o√π leur utilisation est √©vidente, comme `Write-Host`, `Where-Object` ou `ForEach-Object`, mais r√®gle g√©n√©rale, on pr√©f√®re voir le nom des param√®tres.

```powershell
‚ùå dir C:\Windows

‚úÖ Get-ChildItem -Path "C:\Windows"
```

### Commentaires

Il est important de bien documenter son code au moyen de commentaires pertinents. Un commentaire est du texte compris √† l'int√©rieur du fichier mais qui est ignor√© pendant l'ex√©cution du script. La plupart des √©diteurs de scripts afficheront les commentaires d'une couleur distinctive, g√©n√©ralement en vert.

En PowerShell, le caract√®re qui d√©signe les commentaires est le carr√© ou *hash* (`#`). D√®s qu'un `#` est rencontr√© sur une ligne, tous les caract√®res jusqu'√† la fin de la ligne sont ignor√©s. Si la ligne commence par un `#`, c'est la ligne au complet qui est ignor√©e.

Il est aussi possible de d√©finir un bloc de commentaires sur plusieurs lignes. Dans ce cas, le bloc commence par `<#` et finit par `#>`.

```powershell
<#
    Ceci est un exemple. 
    Voici un bloc de commentaires.
#>

$Path = "C:\Minou" # le r√©pertoire

If (-not (Test-Path -Path $Path)) {
    # Le r√©pertoire n'existe pas, alors on le cr√©√©e
    New-Item -Path "C:\Minou" -ItemType Directory
}
```

:::caution

N'en faites pas trop! Un commentaire est utile mais un code clair et lisible est mieux. C'est pour cela qu'on pr√©f√®re utiliser les vrais noms des commandes et des param√®tres; les commandes parlent d'elles-m√™mes. Les commentaires devraient √™tre utilis√©s lorsque la logique est complexe ou pour donner du contexte, pour expliquer **pourquoi** une commande est utilis√© √† cet endroit dans le script plut√¥t que ce qu'elle fait.

:::


### Indentation

L'indentation est importante en programmation, car elle permet de voir visuellement dans quel bloc se situe le code. C'est particuli√®rement utile dans une structure de contr√¥le, comme une condition ou une boucle.

Par convention, un niveau d'indentation est √©quivalent √† quatre espaces. C'est cette taille de tabulation que Visual Studio Code ins√®re lorsqu'on presse la touche de tabulation.

![image](./assets/r03/r05_07a.png)

:::danger

PowerShell n'impose pas l'indentation, contrairement √† Python par exemple. Elle sert uniquement √† la lisibilit√©. Toutefois, m√™me si votre code PowerShell fonctionne sans indentation, vous risquez de perdre des points dans vos √©valuation si votre code est mal indent√©.

:::

Il y a √©galement des pr√©f√©rences quant √† si l'ouverture d'accolades se fait sur la m√™me ligne ou sur la ligne suivante. Certains programmeurs pr√©f√®rent la premi√®re forme, d'autres la deuxi√®me. Les deux sont valides, mais celle qui est configur√©e par d√©faut dans VS Code dans les laboratoires est celle du professeur, o√π les accolades commencent √† la fin de la ligne.

:::tip

Visual Studio Code est capable d'ajuster automatiquement les indentations en fonction des ouvertures et fermetures de blocs. Vous n'avez qu'√† lancer la fonctionnalit√© de mise en forme par le menu contextuel ou avec le raccourci clavier `Maj+Alt+F`.

![image](./assets/r03/r05_07b.png)

:::


