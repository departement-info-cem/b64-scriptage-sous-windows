---
title: R10 - WinRM et planification
slug: "10"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 10 - WinRM et planification

:::note R√©sum√© de la s√©ance du vendredi 24 novembre 2023

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

- Protocoles de communication pour l'administration √† distance
  - MSRPC / DCOM
  - WinRM / WS-Management
- Sessions PowerShell √† distance (PSRemoting et WinRM)
  - Interactif par la console (Enter-PSSession, Exit-PSSession...)
  - Dans un script (New-PSSession, Invoke-Command...)
- Planification de t√¢ches
  - Par l'interface graphique
  - Au moyen de commandes PowerShell
  - √Ä distance via WinRM

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

Faites la partie 2 du [TP2](../tp/tp2.md#partie-2-script-de-d%C3%A9ploiement).

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::


## WMI √† distance

On peut lancer des requ√™tes WMI √† distance sur une machine du r√©seau, en sp√©cifiant le param√®tre `-ComputerName` de la commande `Get-WmiObject`.

Pour que ce soit possible, il faut s'assurer de plusieurs choses:
- La machine distante est joignable sur le r√©seau
- Le service WMI (winmgmt) est actif sur la machine distante (c'est le cas par d√©faut)
- Nous avons des droits d'administration sur la machine distante
- Le pare-feu laisse passer le trafic WMI

Lorsque les machines sont membres du domaine et que nous sommes authentifi√©s avec un compte qui poss√®de des droits d'administration sur les machines (c'est le cas du compte d'admin du domaine), il suffit de pr√©ciser le nom de la machine et les requ√™tes se font √† travers le r√©seau.

![](./assets/r10/wmi_remote_01.png)


Le param√®tre `-ComputerName` est de type `string[]`, donc il est possible de lui donner plusieurs ordinateurs, ou encore de lui passer un tableau de strings.

![](./assets/r10/wmi_remote_02.png)

![](./assets/r10/wmi_remote_03.png)

:::tip
M√™me si le nom du param√®tre sugg√®re qu'on doive passer un nom d'ordinateur, on peut aussi passer l'adresse IP num√©rique de l'ordinateur ou encore le nom DNS complet (FQDN). Dans un environnement de domaine simple, on tend souvent √† n'indiquer que le nom de l'ordinateur, puisque les machines membres du domaine vont automatiquement appliquer le suffixe DNS de leur domaine. 

Concernant les r√©solutions de nom court: Par exemple, si on tente de r√©soudre le serveur *SRV01* sur une machine client membre du domaine *auto.cemti.ca*, la r√©solution r√©elle se fera sur *SRV01.auto.cemti.ca*. 
:::


### Pr√©paration

Dans plusieurs cas, l'administration √† distance de Windows est d√©sactiv√©e pour des raisons de s√©curit√©. On l'active au besoin. Dans plusieurs entreprises, o√π la gestion des ordinateurs √† distance est importante, ces configurations sont automatis√©es.

#### Pare-feu

WMI repose sur DCOM et RPC, deux protocoles d'administration √† distance int√©gr√©s √† Windows. Ceux-ci sont actifs par d√©faut sous Windows, mais le pare-feu bloque le trafic provenant de l'ext√©rieur. Pour permettre de passer des requ√™tes WMI √† une machine distante, il faut ouvrir le pare-feu des machine sur lesquelles vous voulez vous connecter.

Pour ce faire, d√©marrez la console avanc√©e du pare-feu de Windows (wf.msc) et activez l'ensemble de r√®gles du groupe "Windows Management Instrumentation".

![](./assets/r10/wmi_remote_04.png)

![](./assets/r10/wmi_remote_05.png)

Vous pouvez maintenant tester la connexion en sp√©cifiant les param√®tres `ComputerName` et `Credential` (si n√©cessaire).

![](./assets/r10/wmi_remote_06.png)


### Get-Credential

Pour administrer une machine √† distance, il faut minimalement avoir les privil√®ges pour l'administrer.

Dans un domaine Active Directory, l'authentification est g√©n√©ralement int√©gr√©e. Lorsque vous ouvrez une session sur votre machine avec votre compte AD, c'est ce m√™me compte qui sera automatiquement pass√© √† la machine distante que vous tentez d'administrer. Cela simplifie beaucoup les choses.

Lorsqu'on veut poser une action sur un serveur distant avec un compte diff√©rent de celui dont on s'est servi pour s'authentifier √† notre machine, une mani√®re de proc√©der est par l'emploi de la commande `Get-Credential`.

![](./assets/r10/pscredential_01.png)

L'objet retourn√© est de type `PSCredential` et est le type d'objet √† passer lorsqu'une commande poss√®de un param√®tre `Credential`

![](./assets/r10/pscredential_02.png)


:::tip
On ne devrait jamais utiliser `Get-Credential` dans un script ou une fonction, car cela force une action de l'utilisateur m√™me s'il poss√®de d√©j√† des droits suffisants. √áa l'obligerait √† se r√©authentifier √† chaque lancement du script. On ne devrait utiliser `Get-Credential` que lorsque l'utilisateur doit utiliser un compte diff√©rent que celui avec lequel il op√®re sa session PowerShell.

En fait, on devrait plut√¥t cr√©er un param√®tre `-Credential` non-obligatoire dont la valeur par d√©faut est un jeton vide.

```powershell
[CmdletBinding()]
Param(
    [System.Management.Automation.PSCredential]
    $Credential = [System.Management.Automation.PSCredential]::Empty
)
```

On passe alors `$Credential` dans les param√®tres `-Credential` des commandes qui sont appel√©es. Si le param√®tre n'a pas √©t√© sp√©cifi√© au lancement du script, le jeton est vide, et cela indique √† la commande d'ex√©cuter la commande au nom de l'utilisateur qui l'appelle.

`Get-Credential` devrait seulement √™tre utilis√© au moment d'appeler le script, au besoin.

```powershell
.\MonScript.ps1 -Credential (Get-Credential)
```
:::


### Objets PSCredential

Creusons un peu dans l'objet `PSCredential`.

Cet objet poss√®de deux propri√©t√©s: `UserName` et `Password`.

![](./assets/r10/pscredential_04.png)

Pourtant, le mot de passe n'est pas visible. Il s'agit d'un objet `SecureString`.

![](./assets/r10/pscredential_05.png)

Les objets `SecureString` servent principalement √† stocker des mots de passe de mani√®re s√©curitaire. On peut leur affecter une cha√Æne de caract√®res, mais on ne peut pas la lire. Le mot de passe contenu dans cet objet est chiffr√©.

![](./assets/r10/pscredential_06.png)


### RPC et WinRM

Le syst√®me d'exploitation Windows offre plusieurs options pour permettre aux administrateurs syst√®mes de les administrer √† distance, √† travers le r√©seau.

Nous avons vu pr√©c√©demment comment les requ√™tes WMI, √† l'aide de la commande `Get-WmiObject`, peuvent √™tre pass√©es √† des h√¥tes distants. C'est possible au moyen du protocole RPC (Remote Procedure Call), un protocole datant des ann√©es 80. Microsoft a utilis√© RPC dans ses outils de gestion d√®s les d√©buts de Windows NT, dans les ann√©es 90, et est encore aujourd'hui largement utilis√©. C'est ce protocole qui permet l'administration √† distance avec WMI et les consoles de gestion MMC (comme Computer Management).

RPC n'a pas √©t√© con√ßu pour la s√©curit√©, qui n'√©tait pas un grand enjeu √† l'√©poque. Microsoft a fait √©voluer le protocole, lui greffant des routines de s√©curit√©, mais √ßa a donn√© un protocole tr√®s complexe et fragile. La nature du protocole oblige, entre autres, √† ouvrir un tr√®s grand nombre de ports entrants (tous les ports de 1024-65535, √©ventuellement r√©duit √† 49152-65535), ce qui √©largit la surface d'exposition √† des menaces ext√©rieures. Aussi, le trafic RPC n'est g√©n√©ralement pas chiffr√© (√† l'exception des credentials).

Microsoft a donc d√©velopp√© un nouveau protocole d'administration √† distance pour Windows, avec cette fois-ci la s√©curit√© en t√™te. Ce protocole, c'est WinRM. Il est bas√© sur HTTP/HTTPS, comme pour le Web.


### Activation de WinRM sur un serveur

Pour activer WinRM sur une machine (la machine qui va recevoir la connexion), on peut utiliser la commande suivante, dans une console powershell √©lev√©e (en tant qu'administrateur)

```powershell
Enable-PSRemoting -Force
```

Si WinRM est d√©j√† activ√©, la commande vous le dira. Sinon, la commande se chargera d'activer WinRM pour vous, incluant le service et le pare-feu.

On peut √©galement utiliser la commande winrm quickconfig pour arriver au m√™me r√©sultat.


:::tip
Si votre serveur n'est pas dans un domaine, on peut activer WinRM mais la proc√©dure est diff√©rente.

Comme le profil de connexion n'est pas celle d'un domaine, Windows le consid√®re moins s√©curitaire. Si votre serveur est connect√© dans un environnement que vous consid√©rez s√©curitaire (un r√©seau local d'entreprise par exemple), vous pouvez demander de sauter la v√©rification.

```powershell
Enable-PSRemoting -Force -SkipNetworkProfileCheck
```

Aussi, il faut pr√©ciser la liste des machines de confiance. Lorsqu'on est dans un domaine, toutes les machines membres du domaine sont dignes de confiance. Lorsqu'on n'est pas dans un domaine, on doit les d√©finir.

```powershell
Set-Item WSMAN:\localhost\Client\TrustedHosts -Value "192.168.123.45" -Force
```

Si vous voulez accepter la connexion de n'importe quelle machine du r√©seau, vous pouvez mettre * comme valeur. Mais sachez que ce n'est pas une bonne pratique de s√©curit√©.

Ensuite, red√©marrez le service WinRM pour que les changements soient pris en compte.

```powershell
Restart-Service WinRM
```
:::

#### Le pare-feu

Normalement, la r√®gle de pare-feu est cr√©√©e automatiquement. Vous pouvez vous en assurer dans la console du pare-feu (wf.msc).

![](./assets/r10/winrm_firewall01.png)


#### Chiffrement

Une bonne pratique, lorsqu'on active WinRM, est de permettre le chiffrement du trafic. Par d√©faut, c'est HTTP qui est utilis√© et pas HTTPS. Pour permettre le chiffrement du trafic, tout comme avec HTTPS pour le Web, on a besoin d'un certificat SSL. On n'entrera pas dans ces d√©tails dans le cadre de ce cours, mais si √ßa vous int√©resse, consultez ce guide: https://4sysops.com/archives/powershell-remoting-over-https-with-a-self-signed-ssl-certificate/.



## Sessions PowerShell √† distance

Une fois que WinRM a √©t√© activ√© sur le serveur, vous pouvez maintenant vous y ouvrir une session PowerShell distante. Pour ce faire, utilisez les commandes dont le nom est PSSession.

![](./assets/r10/psremoting_01.png)

Pour acc√©der √† la ligne de commande √† distance, la commande √† utiliser est `Enter-PSSession`.

![](./assets/r10/psremoting_02.png)

Une fois dans la session distante, on voit le nom du serveur dans l'invite. Toutes les commandes qu'on tape ici seront faites comme si nous √©tions physiquement sur le serveur.

![](./assets/r10/psremoting_03.png)

Pour quitter la session, vous pouvez utiliser la commande `Exit-PSSession`.

![](./assets/r10/psremoting_04.png)


### Authentification

Dans un environnement Active Directory, on se connecte au serveur distant en utilisant par d√©faut l'identit√© de l'utilisateur pr√©sentement logg√©. On peut utiliser le param√®tre `-Credential` pour sp√©cifier un utilisateur diff√©rent.

En entreprise, il n'est pas rare de recourir √† cette fa√ßon de faire. Les utilisateurs (m√™me les admins) utilisent un compte r√©gulier, sans droits d'administration, pour travailler sur leur poste de travail. Ils ont un deuxi√®me compte, qu'ils utilisent pour se connecter √† des sessions distantes, et c'est ce compte qui poss√®de les droits d'administration.

Dans cet exemple, l'utilisateur du syst√®me est logg√© avec le compte alice, qui n'a aucun droit d'administration. Lorsqu'on tente de se connecter sur le serveur, l'acc√®s est refus√©.

![](./assets/r10/psremoting_auth_01.png)

Pour se connecter en tant qu'un utilisateur qui poss√®de des droits sur ce syst√®me, il faut sp√©cifier les credentials. On les obtient avec `Get-Credential`.

![](./assets/r10/psremoting_auth_02.png)


Et on passe cet objet dans le param√®tre -Credential.

![](./assets/r10/psremoting_auth_03.png)


### Cr√©er des sessions PowerShell

Les sessions interactives, c'est bien, mais on doit faire toutes nos commandes dans l'ordinateur distant. Si on a un script √† ex√©cuter, il faut d'abord le transf√©rer sur l'ordinateur distant, ce qui n'est pas pratique.

On peut ouvrir des sessions PowerShell √† distance, non pas pour acc√©der √† la console, mais pour y lancer des commandes.

#### Cr√©er la session

On cr√©er une nouvelle session avec la commande `New-PSSession`. Celle-ci sera ouverte et portera un num√©ro d'identification.

![](./assets/r10/psremoting_05.png)

#### Obtenir les sessions existantes

On peut obtenir l'√©tat des sessions en cours avec `Get-PSSession`.

![](./assets/r10/psremoting_06.png)

#### Affecter une session √† une variable

Pour obtenir une session sp√©cifique et la mettre dans une variable, on peut l'affecter avec `Get-PSSession` si la session est d√©j√† ouverte, ou encore, l'affecter directement avec `New-PSSession`.

![](./assets/r10/psremoting_07.png)

![](./assets/r10/psremoting_08.png)


#### Terminer une session

![](./assets/r10/psremoting_09.png)


#### Terminer toutes les sessions ouvertes

![](./assets/r10/psremoting_10.png)


### Invoke-Command

La commande Invoke-Command ex√©cute une commande √† distance. Elle est √©quivalente √† appeler powershell.exe sur la machine distante.

On peut l'utiliser de deux mani√®res.

#### Ex√©cuter un bloc de commandes

Le bloc de commandes se d√©finit avec le param√®tre `-ScriptBlock`, entre accolades. C'est pratique pour lancer une commande simple sur les machines distantes.

![](./assets/r10/psremoting_invoke-command_01.png)


:::caution
Une session PSSession √† distance correspond √† une session PowerShell ouverte sur une autre machine. Par cons√©quent, elle est distincte de la session locale. Par exemple, une variable qu'on d√©finit dans la session locale ne sera pas accessible sur la session distante.

```powershell
$NouveauDossier = "C:\MonDossier"
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item -Path $NouveauDossier -ItemType Directory  # Ne fonctionnera pas!
}
```

L'exemple pr√©c√©dent ne fonctionnera pas, puisque la variable `$NouveauDossier` n'a jamais √©t√© cr√©√©e dans la session distante. Elle n'existe que dans la session locale.

Pour pouvoir r√©cup√©rer une variable locale dans un bloc de code √† envoyer √† une machine distante, il faut utiliser le pr√©fixe `$using:` avant le nom de la variable.

```powershell
$NouveauDossier = "C:\MonDossier"
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item -Path $using:NouveauDossier -ItemType Directory
}
```

On peut aussi effectuer un *splatting* avec un hashtable d√©fini localement dans une commande distante avec le pr√©fixe `@using:`, de la m√™me mani√®re.

```powershell
$NouveauDossierSplat = @{
    Path = "C:\MonDossier"
    ItemType = "Directory"
}
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item @using:NouveauDossierSplat
}
```
:::


#### Ex√©cuter un script

Lorsqu'on a un plus grand nombre de commandes √† lancer sur la machine distante, on peut appeler un script.

Dans cet exemple, on cr√©e un script tout simple compos√© seulement de la commande `Get-Process`, mais √ßa pourrait √™tre un script beaucoup plus complexe. Ce script sera lanc√© dans la session distante.

![](./assets/r10/psremoting_invoke-command_02.png)



#### Sp√©cifier les noms de machines au lieu des sessions

On peut aussi cr√©er les sessions automatiquement, en sp√©cifiant les noms de machines plut√¥t que des sessions, mais si vous avez plusieurs commandes √† lancer, il sera plus pratique de r√©utiliser la m√™me session pour chacune des commandes au lieu de les r√©initier √† chaque fois.

![](./assets/r10/psremoting_invoke-command_03.png)


### PSRemoting et pipeline

Comme c'est une session PowerShell, ce qui sort de la commande distante, c'est un objet. Et cet objet sort sur le pipeline local du client. Autrement dit, quand la commande est lanc√©e √† distance, ce qu'elle laisse dans le pipeline revient √† l'appelant, et nous pouvons manipuler cet objet √† notre guise.

![](./assets/r10/psremoting_invoke-command_04.png)

On peut aussi affecter cet objet dans une variable.

![](./assets/r10/psremoting_invoke-command_05.png)


### Plusieurs sessions en m√™me temps

On peut lancer une commande sur plusieurs sessions d'un coup. 

![](./assets/r10/psremoting_invoke-command_06.png)


### Copie de fichiers √† travers une session

Il est possible de copier un fichier √† travers une session PSRemoting √† l'aide de la commande `Copy-Item`.


#### De la machine locale vers la machine distante

Si on sp√©cifie le param√®tre `-ToSession`, on envoie le fichier vers la machine cible. Le param√®tre -Path repr√©sente donc le chemin sur la machine locale, et le param√®tre -Destination repr√©sente le chemin sur la machine distante.

![](./assets/r10/psremoting_copy-item_01.png)


#### De la machine distante vers la machine locale

√Ä l'inverse, si on sp√©cifie le param√®tre `-FromSession`, alors on tire le fichier de l'ordinateur distant vers l'ordinateur local. Le param√®tre `-Path` repr√©sente alors le chemin sur la machine distante, et le param√®tre `-Destination`, celui sur la machine locale.

![](./assets/r10/psremoting_copy-item_02.png)



## Le planificateur de t√¢ches

Le planificateur de t√¢ches sert, comme son nom l'indique, √† planifier des op√©rations sous Windows afin qu'elles d√©marrent automatiquement selon certains crit√®res et dans certaines conditions. Il est tr√®s utile dans de nombreux contextes, comme la planification de t√¢ches de maintenance r√©guli√®res, le d√©marrage d'op√©rations automatique au d√©marrage du syst√®me ou √† l'ouverture d'une session utilisateur, le nettoyage automatique de fichiers temporaires, la prise de sauvegardes r√©guli√®res, etc.

Avec l'interface graphique, on utilise la console MMC du planificateur de t√¢ches, `taskschd`, ou encore la console de gestion de l'ordinateur, `compmgmt.msc`.

![](./assets/r10/taskschd_01.png)

Les t√¢ches planifi√©es sont organis√©es sous forme d'arborescence. La racine (nomm√©e "biblioth√®que du planificateur de t√¢ches", ou simplement, **/**) contient un certain nombre de t√¢ches planifi√©es d√©j√† mises en place √† l'installation de Windows ou d'un logiciel, mais d'autres t√¢ches sont stock√©es dans des conteneurs sous la racine.

![](./assets/r10/taskschd_02.png)

Pour cr√©er une t√¢che √† l'aide de l'interface graphique, il suffit d'ouvrir le menu contextuel par un clic-droit sur le conteneur o√π cr√©er la t√¢che. Il existe deux mani√®re de cr√©er une t√¢che: simplifi√©e ("*cr√©er une t√¢che de base...*") et avanc√©e ("*cr√©er une t√¢che...*"). Il est pr√©f√©rable de ne pas choisir une t√¢che de base, puisque certaines options sont inaccessibles.

![](./assets/r10/taskschd_03.png)


### Composition d'une t√¢che planifi√©e

Une t√¢che planifi√©e est en ensemble de plusieurs √©l√©ments d'information. Ils sont assembl√©s ensemble pour former une t√¢che planifi√©e incrite dans le planificateur.

![](./assets/r10/taskschd_05.png)

- L'information d'enregistrement (**RegistrationInfo**) contient les propri√©t√©s de la t√¢che qui concernent son enregistrement dans le planificateur, comme le nom de la t√¢che, sa description et son emplacement dans l'arborescence du planificateur.

- Les d√©clencheurs (**Trigger**) d√©finissent dans quelle circonstance la t√¢che pourra √™tre lanc√©e. Par exemple, au d√©marrage de l'ordinateur, √† l'ouverture de session, √† chaque vendredi minuit, ou m√™me lorsqu'un √©v√©nement syst√®me est d√©tect√©. Il peut y en avoir plus d'un.

- Les actions (**Action**) d√©finissent une action (comme le lancement d'une commande ou d'un script) √† ex√©cuter chaque fois que la t√¢che est d√©clench√©e. Il peut y en avoir plusieurs.

- Le principal de s√©curit√© (**Principal**) d√©crit avec quelle identit√© (un compte utilisateur ou un groupe) la t√¢che sera lanc√©e. Si le principal est un compte utilisateur, alors c'est sous ce compte que la t√¢che sera ex√©cut√©e (comme si l'utilisateur l'avait fait manuellement). Si le principal est un groupe, la t√¢che sera lanc√©e au nom de l'utilisateur courant uniquement s'il est membre de ce groupe.

- Les param√®tres (**Settings**) d√©crivent diverses options concernant la t√¢che. Par exemple, la t√¢che doit-elle √™tre ex√©cut√©e m√™me si l'ordinateur tourne sur la batterie, ou le comportement √† adopter si la t√¢che √©choue.

![](./assets/r10/taskschd_04.png)

### D√©clencheur (*Trigger*)

Une t√¢che planifi√©e comprend un ou plusieurs d√©clencheurs, c'est-√†-dire des √©v√©nements qui d√©marreront automatiquement la t√¢che.

![](./assets/r10/taskschd_trigger01.png)

Plusieurs types de d√©clencheurs sont disponibles:
- √Ä l'heure programm√©e
- √Ä l'ouverture de session
- Au d√©marage
- Apr√®s une p√©riode d'activit√© 
- Sur un √©v√©nement (syst√®me)
- Lors de la cr√©ation/modification de la t√¢che
- Au moment de la connexion √† une session utilisateur (par exemple, RDP)
- Au moment de la d√©connexion √† une session utilisateur
- Au verrouillage du poste de travail (Win+L)
- Au d√©verrouillage du poste de travail

### Action (*Action*)

Une t√¢che planifi√©e comprend une ou plusieurs actions qui seront lanc√©es lorsque la t√¢che sera d√©clench√©e. Le principal type d'action est le lancement d'une commande ("*d√©marrer un programme*").

![](./assets/r10/taskschd_action01.png)

Pour lancer une commande, il faut d√©finir trois param√®tres:

| Param√®tre | Description |
| -- | -- |
| Programme/script | Le nom ou chemin du fichier ex√©cutable √† appeler seulement. |
| Ajouter des arguments (facultatif) | Tous les arguments apr√®s le nom de l'ex√©cutable. |
| Commencer dans (facultatif) | Le r√©pertoire de travail dans lequel lancer la commande. |

Par exemple, pour qu'une t√¢che ex√©cute le script PowerShell `C:\Scripts\MonScript.ps1`, il faudrait que le nom du programme soit `powershell.exe` et que les arguments soient `-File C:\Scripts\MonScript.ps1 -ExecutionPolicy Bypass`.

![](./assets/r10/taskschd_action02.png)

:::tip
Pour conna√Ætre la syntaxe de la commande Powershell.exe, vous pouvez lancer `Powershell.exe /?` pour acc√©der √† la rubrique d'aide.

![](./assets/r10/taskschd_action03.png)
:::


### Conditions et param√®tres

Les onglets Conditions et Param√®tres contiennent des options suppl√©mentaires sur la t√¢che.

![](./assets/r10/taskschd_condition01.png)

![](./assets/r10/taskschd_parameters01.png)


### Forcer le lancement une t√¢che planifi√©e

On peut forcer l'ex√©cution d'une t√¢che planifi√©e directement par la console. C'est pratique pour la tester.

![](./assets/r10/taskschd_forceexec.png)

:::tip
Comme bien des consoles MMC, vous pouvez g√©rer les t√¢ches planifi√©es sur une machine distante √† partir de la console. Vous devez √™tre administrateur local de la machine distante, et les pare-feux doivent laisser passer le protocole MSRPC.

![](./assets/r10/taskschd_remote.png)
:::


## Gestion des t√¢ches planifi√©es en PowerShell

PowerShell offre un ensemble de commandes pour contr√¥ler, localement ou √† distance, les t√¢ches planifi√©es.

Pour ce faire, il y a plusieurs commandes √† faire, puisqu'il faut cr√©er chaque √©l√©ment de la t√¢che planifi√©e individuellement, puis les mettre ensemble pour l'enregistrer dans la biblioth√®que du planificateur de t√¢ches.

### D√©finir le d√©clencheur

Il existe plusieurs d√©clencheurs. Il suffit ici de cr√©er un nouveau d√©clencheur du type souhait√©. Il faut le stocker dans une variable.

![](./assets/r10/taskschd_posh_newtrigger.png)


### D√©finir l'action

Il faut d√©finir l'action, soit le programme a ex√©cuter. Tout comme avec l'interface graphique, le programme √† sp√©cifier dans le param√®tre -Execute n'est que l'ex√©cutable √† lancer. Si c'est un script PowerShell, alors on met "powershell.exe". Si c'est un autre programme, on met uniquement le nom du programme, sans ses arguments.

![](./assets/r10/taskschd_posh_newaction.png)


### D√©finir le principal

Le principal d√©signe l'utilisateur au nom duquel la t√¢che sera ex√©cut√©e.

Nous avons deux options:
- Sp√©cifier un compte utilisateur sp√©cifique (`-UserID`)
- Sp√©cifier un groupe (`-GroupID`)

![](./assets/r10/taskschd_posh_newprincipal.png)

Si le principal est un utilisateur, la t√¢che sera faite au nom de ce compte pr√©cis.

Si le principal est un groupe, la t√¢che sera faite au nom de l'utilisateur courant, uniquement si celui-ci fait partie du groupe. Lorsque le principal est un groupe, il est impossible que la t√¢che soit lanc√©e lorsque l'utilisateur n'est pas logg√©.


### Enregistrer la t√¢che planifi√©e

Une fois tous les √©l√©ments en place, il ne reste plus qu'√† enregistrer la t√¢che planifi√©e. On lui donne alors un nom, une description et un emplacement dans le planificateur, puis on lui donne une ou plusieurs actions, un ou plusieurs d√©clencheurs ainsi qu'un principal.

![](./assets/r10/taskschd_posh_register.png)


:::tip
Il est aussi possible de contr√¥ler les t√¢ches planifi√©es sur un ordinateur distant. On peut simplement passer par une session distante (PSSession) au moyen de la commande Invoke-Command.

![](./assets/r10/taskschd_posh_remote01.png)
:::
