---
title: R10 - PSRemoting et planification de t√¢ches
slug: "10"
draft: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 10 - PSRemoting et planification de t√¢ches

:::note R√©sum√© de la s√©ance

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">



</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">


</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::


## WMI √† distance

On peut lancer des requ√™tes WMI √† distance sur une machine du r√©seau, en sp√©cifiant le param√®tre `-ComputerName` de la commande `Get-WmiObject`.

Pour que ce soit possible, il faut s'assurer de plusieurs choses:
- La machine distante est joignable sur le r√©seau
- Le service WMI (winmgmt) est actif sur la machine distante (c'est le cas par d√©faut)
- Nous avons des droits d'administration sur la machine distante
- Le pare-feu laisse passer le trafic WMI

Lorsque les machines sont membres du domaine et que nous sommes authentifi√©s avec un compte qui poss√®de des droits d'administration sur les machines (c'est le cas du compte d'admin du domaine), il suffit de pr√©ciser le nom de la machine et les requ√™tes se font √† travers le r√©seau.

![](./assets/r10/wmi_remote_01.png)


Le param√®tre `-ComputerName` est de type `string[]`, donc il est possible de lui donner plusieurs ordinateurs, ou encore de lui passer un tableau de strings.

![](./assets/r10/wmi_remote_02.png)

![](./assets/r10/wmi_remote_03.png)

:::tip
M√™me si le nom du param√®tre sugg√®re qu'on doive passer un nom d'ordinateur, on peut aussi passer l'adresse IP num√©rique de l'ordinateur ou encore le nom DNS complet (FQDN). Dans un environnement de domaine simple, on tend souvent √† n'indiquer que le nom de l'ordinateur, puisque les machines membres du domaine vont automatiquement appliquer le suffixe DNS de leur domaine. 

Concernant les r√©solutions de nom court: Par exemple, si on tente de r√©soudre le serveur *SRV01* sur une machine client membre du domaine *auto.cemti.ca*, la r√©solution r√©elle se fera sur *SRV01.auto.cemti.ca*. 
:::


### Pr√©paration

Dans plusieurs cas, l'administration √† distance de Windows est d√©sactiv√©e pour des raisons de s√©curit√©. On l'active au besoin. Dans plusieurs entreprises, o√π la gestion des ordinateurs √† distance est importante, ces configurations sont automatis√©es.

#### Pare-feu

WMI repose sur DCOM et RPC, deux protocoles d'administration √† distance int√©gr√©s √† Windows. Ceux-ci sont actifs par d√©faut sous Windows, mais le pare-feu bloque le trafic provenant de l'ext√©rieur. Pour permettre de passer des requ√™tes WMI √† une machine distante, il faut ouvrir le pare-feu des machine sur lesquelles vous voulez vous connecter.

Pour ce faire, d√©marrez la console avanc√©e du pare-feu de Windows (wf.msc) et activez l'ensemble de r√®gles du groupe "Windows Management Instrumentation".

![](./assets/r10/wmi_remote_04.png)

![](./assets/r10/wmi_remote_05.png)

Vous pouvez maintenant tester la connexion en sp√©cifiant les param√®tres `ComputerName` et `Credential` (si n√©cessaire).

![](./assets/r10/wmi_remote_06.png)


### Get-Credential

Pour administrer une machine √† distance, il faut minimalement avoir les privil√®ges pour l'administrer.

Dans un domaine Active Directory, l'authentification est g√©n√©ralement int√©gr√©e. Lorsque vous ouvrez une session sur votre machine avec votre compte AD, c'est ce m√™me compte qui sera automatiquement pass√© √† la machine distante que vous tentez d'administrer. Cela simplifie beaucoup les choses.

Lorsqu'on veut poser une action sur un serveur distant avec un compte diff√©rent de celui dont on s'est servi pour s'authentifier √† notre machine, une mani√®re de proc√©der est par l'emploi de la commande `Get-Credential`.

![](./assets/r10/pscredential_01.png)

L'objet retourn√© est de type `PSCredential` et est le type d'objet √† passer lorsqu'une commande poss√®de un param√®tre `Credential`

![](./assets/r10/pscredential_02.png)


:::tip
On ne devrait jamais utiliser `Get-Credential` dans un script ou une fonction, car cela force une action de l'utilisateur m√™me s'il poss√®de d√©j√† des droits suffisants. √áa l'obligerait √† se r√©authentifier √† chaque lancement du script. On ne devrait utiliser `Get-Credential` que lorsque l'utilisateur doit utiliser un compte diff√©rent que celui avec lequel il op√®re sa session PowerShell.

En fait, on devrait plut√¥t cr√©er un param√®tre `-Credential` non-obligatoire dont la valeur par d√©faut est un jeton vide.

```powershell
[CmdletBinding()]
Param(
    [System.Management.Automation.PSCredential]
    $Credential = [System.Management.Automation.PSCredential]::Empty
)
```

On passe alors `$Credential` dans les param√®tres `-Credential` des commandes qui sont appel√©es. Si le param√®tre n'a pas √©t√© sp√©cifi√© au lancement du script, le jeton est vide, et cela indique √† la commande d'ex√©cuter la commande au nom de l'utilisateur qui l'appelle.

`Get-Credential` devrait seulement √™tre utilis√© au moment d'appeler le script, au besoin.

```powershell
.\MonScript.ps1 -Credential (Get-Credential)
```
:::


### Objets PSCredential

Creusons un peu dans l'objet `PSCredential`.

Cet objet poss√®de deux propri√©t√©s: `UserName` et `Password`.

![](./assets/r10/pscredential_04.png)

Pourtant, le mot de passe n'est pas visible. Il s'agit d'un objet `SecureString`.

![](./assets/r10/pscredential_05.png)

Les objets `SecureString` servent principalement √† stocker des mots de passe de mani√®re s√©curitaire. On peut leur affecter une cha√Æne de caract√®res, mais on ne peut pas la lire. Le mot de passe contenu dans cet objet est chiffr√©.

![](./assets/r10/pscredential_06.png)


### RPC et WinRM

Le syst√®me d'exploitation Windows offre plusieurs options pour permettre aux administrateurs syst√®mes de les administrer √† distance, √† travers le r√©seau.

Nous avons vu pr√©c√©demment comment les requ√™tes WMI, √† l'aide de la commande `Get-WmiObject`, peuvent √™tre pass√©es √† des h√¥tes distants. C'est possible au moyen du protocole RPC (Remote Procedure Call), un protocole datant des ann√©es 80. Microsoft a utilis√© RPC dans ses outils de gestion d√®s les d√©buts de Windows NT, dans les ann√©es 90, et est encore aujourd'hui largement utilis√©. C'est ce protocole qui permet l'administration √† distance avec WMI et les consoles de gestion MMC (comme Computer Management).

RPC n'a pas √©t√© con√ßu pour la s√©curit√©, qui n'√©tait pas un grand enjeu √† l'√©poque. Microsoft a fait √©voluer le protocole, lui greffant des routines de s√©curit√©, mais √ßa a donn√© un protocole tr√®s complexe et fragile. La nature du protocole oblige, entre autres, √† ouvrir un tr√®s grand nombre de ports entrants (tous les ports de 1024-65535, √©ventuellement r√©duit √† 49152-65535), ce qui √©largit la surface d'exposition √† des menaces ext√©rieures. Aussi, le trafic RPC n'est g√©n√©ralement pas chiffr√© (√† l'exception des credentials).

Microsoft a donc d√©velopp√© un nouveau protocole d'administration √† distance pour Windows, avec cette fois-ci la s√©curit√© en t√™te. Ce protocole, c'est WinRM. Il est bas√© sur HTTP/HTTPS, comme pour le Web.


### Activation de WinRM sur un serveur

Pour activer WinRM sur une machine (la machine qui va recevoir la connexion), on peut utiliser la commande suivante, dans une console powershell √©lev√©e (en tant qu'administrateur)

```powershell
Enable-PSRemoting -Force
```

Si WinRM est d√©j√† activ√©, la commande vous le dira. Sinon, la commande se chargera d'activer WinRM pour vous, incluant le service et le pare-feu.

On peut √©galement utiliser la commande winrm quickconfig pour arriver au m√™me r√©sultat.


:::tip
Si votre serveur n'est pas dans un domaine, on peut activer WinRM mais la proc√©dure est diff√©rente.

Comme le profil de connexion n'est pas celle d'un domaine, Windows le consid√®re moins s√©curitaire. Si votre serveur est connect√© dans un environnement que vous consid√©rez s√©curitaire (un r√©seau local d'entreprise par exemple), vous pouvez demander de sauter la v√©rification.

```powershell
Enable-PSRemoting -Force -SkipNetworkProfileCheck
```

Aussi, il faut pr√©ciser la liste des machines de confiance. Lorsqu'on est dans un domaine, toutes les machines membres du domaine sont dignes de confiance. Lorsqu'on n'est pas dans un domaine, on doit les d√©finir.

```powershell
Set-Item WSMAN:\localhost\Client\TrustedHosts -Value "192.168.123.45" -Force
```

Si vous voulez accepter la connexion de n'importe quelle machine du r√©seau, vous pouvez mettre * comme valeur. Mais sachez que ce n'est pas une bonne pratique de s√©curit√©.

Ensuite, red√©marrez le service WinRM pour que les changements soient pris en compte.

```powershell
Restart-Service WinRM
```
:::

#### Le pare-feu

Normalement, la r√®gle de pare-feu est cr√©√©e automatiquement. Vous pouvez vous en assurer dans la console du pare-feu (wf.msc).

![](./assets/r10/winrm_firewall01.png)


#### Chiffrement

Une bonne pratique, lorsqu'on active WinRM, est de permettre le chiffrement du trafic. Par d√©faut, c'est HTTP qui est utilis√© et pas HTTPS. Pour permettre le chiffrement du trafic, tout comme avec HTTPS pour le Web, on a besoin d'un certificat SSL. On n'entrera pas dans ces d√©tails dans le cadre de ce cours, mais si √ßa vous int√©resse, consultez ce guide: https://4sysops.com/archives/powershell-remoting-over-https-with-a-self-signed-ssl-certificate/.



## Sessions PowerShell √† distance

Une fois que WinRM a √©t√© activ√© sur le serveur, vous pouvez maintenant vous y ouvrir une session PowerShell distante. Pour ce faire, utilisez les commandes dont le nom est PSSession.

![](./assets/r10/psremoting_01.png)

Pour acc√©der √† la ligne de commande √† distance, la commande √† utiliser est `Enter-PSSession`.

![](./assets/r10/psremoting_02.png)

Une fois dans la session distante, on voit le nom du serveur dans l'invite. Toutes les commandes qu'on tape ici seront faites comme si nous √©tions physiquement sur le serveur.

![](./assets/r10/psremoting_03.png)

Pour quitter la session, vous pouvez utiliser la commande `Exit-PSSession`.

![](./assets/r10/psremoting_04.png)


### Authentification

Dans un environnement Active Directory, on se connecte au serveur distant en utilisant par d√©faut l'identit√© de l'utilisateur pr√©sentement logg√©. On peut utiliser le param√®tre `-Credential` pour sp√©cifier un utilisateur diff√©rent.

En entreprise, il n'est pas rare de recourir √† cette fa√ßon de faire. Les utilisateurs (m√™me les admins) utilisent un compte r√©gulier, sans droits d'administration, pour travailler sur leur poste de travail. Ils ont un deuxi√®me compte, qu'ils utilisent pour se connecter √† des sessions distantes, et c'est ce compte qui poss√®de les droits d'administration.

Dans cet exemple, l'utilisateur du syst√®me est logg√© avec le compte alice, qui n'a aucun droit d'administration. Lorsqu'on tente de se connecter sur le serveur, l'acc√®s est refus√©.

![](./assets/r10/psremoting_auth_01.png)

Pour se connecter en tant qu'un utilisateur qui poss√®de des droits sur ce syst√®me, il faut sp√©cifier les credentials. On les obtient avec `Get-Credential`.

![](./assets/r10/psremoting_auth_02.png)


Et on passe cet objet dans le param√®tre -Credential.

![](./assets/r10/psremoting_auth_03.png)


### Cr√©er des sessions PowerShell

Les sessions interactives, c'est bien, mais on doit faire toutes nos commandes dans l'ordinateur distant. Si on a un script √† ex√©cuter, il faut d'abord le transf√©rer sur l'ordinateur distant, ce qui n'est pas pratique.

On peut ouvrir des sessions PowerShell √† distance, non pas pour acc√©der √† la console, mais pour y lancer des commandes.

Cr√©er la session

On cr√©er une nouvelle session avec la commande `New-PSSession`. Celle-ci sera ouverte et portera un num√©ro d'identification.

![](./assets/r10/psremoting_05.png)

Obtenir les sessions existantes

On peut obtenir l'√©tat des sessions en cours avec `Get-PSSession`.

![](./assets/r10/psremoting_06.png)

Affecter une session √† une variable

Pour obtenir une session sp√©cifique et la mettre dans une variable, on peut l'affecter avec `Get-PSSession` si la session est d√©j√† ouverte, ou encore, l'affecter directement avec `New-PSSession`.

![](./assets/r10/psremoting_07.png)

![](./assets/r10/psremoting_08.png)


#### Terminer une session

![](./assets/r10/psremoting_09.png)


#### Terminer toutes les sessions ouvertes

![](./assets/r10/psremoting_10.png)


### Invoke-Command

La commande Invoke-Command ex√©cute une commande √† distance. Elle est √©quivalente √† appeler powershell.exe sur la machine distante.

On peut l'utiliser de deux mani√®res.

#### Ex√©cuter un bloc de commandes

Le bloc de commandes se d√©finit avec le param√®tre `-ScriptBlock`, entre accolades. C'est pratique pour lancer une commande simple sur les machines distantes.

![](./assets/r10/psremoting_invoke-command_01.png)


:::caution
Une session PSSession √† distance correspond √† une session PowerShell ouverte sur une autre machine. Par cons√©quent, elle est distincte de la session locale. Par exemple, une variable qu'on d√©finit dans la session locale ne sera pas accessible sur la session distante.

```powershell
$NouveauDossier = "C:\MonDossier"
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item -Path $NouveauDossier -ItemType Directory  # Ne fonctionnera pas!
}
```

L'exemple pr√©c√©dent ne fonctionnera pas, puisque la variable `$NouveauDossier` n'a jamais √©t√© cr√©√©e dans la session distante. Elle n'existe que dans la session locale.

Pour pouvoir r√©cup√©rer une variable locale dans un bloc de code √† envoyer √† une machine distante, il faut utiliser le pr√©fixe `$using:` avant le nom de la variable.

```powershell
$NouveauDossier = "C:\MonDossier"
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item -Path $using:NouveauDossier -ItemType Directory
}
```

On peut aussi effectuer un *splatting* avec un hashtable d√©fini localement dans une commande distante avec le pr√©fixe `@using:`, de la m√™me mani√®re.

```powershell
$NouveauDossierSplat = @{
    Path = "C:\MonDossier"
    ItemType = "Directory"
}
$Session = New-PSSession -ComputerName "SRV01"

Invoke-Command -Session $Session -ScriptBlock { 
    New-Item @using:NouveauDossierSplat
}
```
:::


#### Ex√©cuter un script

Lorsqu'on a un plus grand nombre de commandes √† lancer sur la machine distante, on peut appeler un script.

Dans cet exemple, on cr√©e un script tout simple compos√© seulement de la commande `Get-Process`, mais √ßa pourrait √™tre un script beaucoup plus complexe. Ce script sera lanc√© dans la session distante.

![](./assets/r10/psremoting_invoke-command_02.png)



#### Sp√©cifier les noms de machines au lieu des sessions

On peut aussi cr√©er les sessions automatiquement, en sp√©cifiant les noms de machines plut√¥t que des sessions, mais si vous avez plusieurs commandes √† lancer, il sera plus pratique de r√©utiliser la m√™me session pour chacune des commandes au lieu de les r√©initier √† chaque fois.

![](./assets/r10/psremoting_invoke-command_03.png)


### PSRemoting et pipeline

Comme c'est une session PowerShell, ce qui sort de la commande distante, c'est un objet. Et cet objet sort sur le pipeline local du client. Autrement dit, quand la commande est lanc√©e √† distance, ce qu'elle laisse dans le pipeline revient √† l'appelant, et nous pouvons manipuler cet objet √† notre guise.

![](./assets/r10/psremoting_invoke-command_04.png)

On peut aussi affecter cet objet dans une variable.

![](./assets/r10/psremoting_invoke-command_05.png)


### Plusieurs sessions en m√™me temps

On peut lancer une commande sur plusieurs sessions d'un coup. 

![](./assets/r10/psremoting_invoke-command_06.png)


### Copie de fichiers √† travers une session

Il est possible de copier un fichier √† travers une session PSRemoting √† l'aide de la commande `Copy-Item`.


#### De la machine locale vers la machine distante

Si on sp√©cifie le param√®tre `-ToSession`, on envoie le fichier vers la machine cible. Le param√®tre -Path repr√©sente donc le chemin sur la machine locale, et le param√®tre -Destination repr√©sente le chemin sur la machine distante.

![](./assets/r10/psremoting_copy-item_01.png)


#### De la machine distante vers la machine locale

√Ä l'inverse, si on sp√©cifie le param√®tre `-FromSession`, alors on tire le fichier de l'ordinateur distant vers l'ordinateur local. Le param√®tre `-Path` repr√©sente alors le chemin sur la machine distante, et le param√®tre `-Destination`, celui sur la machine locale.

![](./assets/r10/psremoting_copy-item_02.png)



## Planification de t√¢ches


