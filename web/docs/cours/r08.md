---
title: R08 - Registre et streams
slug: "08"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 8 - Registre et streams

:::note R√©sum√© de la s√©ance du vendredi 3 novembre 2023

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Retour sur l'examen intra
1. Les fournisseurs PowerShell et les PSDrives
1. Le registre de Windows
1. L'acc√®s au registre avec PowerShell
1. Les streams

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

Exercice 8 sur OneNote

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::

## *PSProvider* et *PSDrive*

Les **fournisseurs PowerShell** (appel√©s *PSProvider*) sont des couches d'abstraction permettant d'obtenir des donn√©es de diff√©rentes natures de mani√®re uniforme.

Par exemple, le syst√®me de fichiers, les variables d'environnement et le registre sont des syst√®mes de donn√©es tr√®s diff√©rents. Gr√¢ce aux providers, on peut les interroger de la m√™me mani√®re et avec les m√™mes commandes.

![Get-PSProvider](./assets/r08/get-psprovider.png)


Voici les principaux providers

| Nom         | Description |
| ----------- | ----------- |
| FileSystem  | Ce provider procure un acc√®s au syst√®me de fichiers. |
| Registry    | Ce provider permet de manipuler la base de registre. |
| Alias       | Ce provider permet de manipuler les alias PowerShell |
| Variable    | Ce provider permet d'interroger et g√©rer les variables PowerShell |
| Function    | Ce provider permet d'interroger et g√©rer les fonctions PowerShell |
| Environment | Ce provider donne acc√®s aux variables d'environnement de la session en cours |


Les **lecteurs PowerShell** (*PSDrive*) sont des points d'entr√©e vers une ressource g√©r√©e par un *PSProvider*. Par exemple, les lecteurs C: et D: sont des lecteurs contenant un syst√®me de fichiers, accessible via le fournisseur *FileSystem*.

![Get-PSDrive](./assets/r08/get-psdrive.png)

Plusieurs commandes PowerShell adoptent un comportement diff√©rent en fonction du fournisseur duquel le chemin sp√©cifi√© est issu. 

Dans l'exemple ci-dessous, on peut voir que le type d'√©l√©ment retourn√© par `Get-ChildItem` est diff√©rent selon que le lecteur sp√©cifi√© en est un expos√© par le fournisseur `FileSystem` ou par le fournisseur `Environment` (qui contient les variables d'environnement).

![Get-PSDrive](./assets/r08/gci-provider.png)



## Le registre de Windows

Le registre de Windows est une base de donn√©es interne √† Windows qui sert √† **centraliser la configuration** du syst√®me d'exploitation et de ses applications afin d'√©viter l'√©parpillement de fichiers de configuration.

Le registre est un composant fondamental du syst√®me d'exploitation. Windows offre diverses m√©thodes permettant aux applications et aux scripts de lire et d'√©crire des valeurs dans le registre.

L'√©diteur de registre (regedit.exe) est un outil int√©gr√© √† Windows qui permet d'explorer le registre √† l'aide d'une interface graphique, √† l'instar de l'explorateur de fichiers permet d'explorer graphiquement le syst√®me de fichiers.


### Structure du registre

Le registre de Windows est compos√© de deux types d'√©l√©ments: les **cl√©s** (*keys*) et les **valeurs** (*values*).

![](./assets/r08/registre_cles-val.png)


### Cl√©s

Les **cl√©s** sont des conteneurs, un peu comme les r√©pertoires dans un syst√®me de fichiers. Elles peuvent contenir des valeurs ainsi que d'autres cl√©s (qu'un appellera sous-cl√©s, ou *subkeys*). Les premi√®res cl√©s, situ√©es au premier niveau de l'arborescence, sont appel√©s des **cl√©s de ruche** (*hive key*) ou des **cl√©s racine** (*root key*) et ont pour pr√©fixe HKEY_ (un diminutif de *hive key*).

![](./assets/r08/registre_cles.png)


### Valeurs

Les **valeurs** sont des √©l√©ments porteurs de donn√©es utilisables. Ils sont comparables aux fichiers dans un syst√®me de fichiers, mais leur contenu tend √† √™tre beaucoup plus petit et circonscrit √† une propri√©t√© ou √† une configuration unique. 

Chaque valeur de registre est contenue dans une cl√© et poss√®de trois attributs: un **nom**, un **type** et une **donn√©e**.

![](./assets/r08/registre_val.png)

Les donn√©es inscrite dans une cl√© doivent √™tre d'un type pr√©cis. Voici les principaux types de donn√©es admissibles pour une valeur de registre:

| Type | Nom | Description |
| -- | -- | -- |
| REG_SZ | String | Une cha√Æne de caract√®res |
| REG_MULTI_SZ | MultiString | Un tableau de cha√Ænes de caract√®res |
| REG_EXPAND_SZ | ExpandString | Une cha√Æne de caract√®res avec variables d'environnement (ex. %APPDATA%) |
| REG_DWORD | DWord | Une valeur num√©rique de 32 bits (√©quivalent √† [uint32]) |
| REG_QWORD | QWord | Une valeur num√©rique de 64 bits (√©quivalent √† [uint64]) |
| REG_BINARY | Binary | Des donn√©es binaires brutes |


### Fichiers du registre

La base de registre est compos√©e de plusieurs fichiers, appel√©s **ruches** (*hive*). Au d√©marrage de Windows (ou d'une session utilisateur), Voici les principaux fichiers qui sont charg√©s:

| Cl√© | Fichier | Port√©e |
| -- | -- | -- |
| HKEY_LOCAL_MACHINE\SOFTWARE | C:\Windows\System32\config\SOFTWARE | Syst√®me |
| HKEY_LOCAL_MACHINE\SECURITY | C:\Windows\System32\config\SECURITY | Syst√®me |
| HKEY_LOCAL_MACHINE\SYSTEM | C:\Windows\System32\config\SYSTEM | Syst√®me |
| HKEY_LOCAL_MACHINE\SAM | C:\Windows\System32\config\SAM | Syst√®me |
| HKEY_USERS\\.DEFAULT | C:\Windows\System32\config\DEFAULT | Syst√®me |
| HKEY_CURRENT_USER | %UserProfile%\NTUSER.DAT | Utilisateur |


### Principales racines

Dans le registre, il y a deux racines fondamentales. 

- **`HKEY_LOCAL_MACHINE (HKLM)`** rassemble la configuration globale du syst√®me
- **`HKEY_USERS (HKU)`** rassemble la configuration des utilisateurs

Il y a aussi plusieurs racines alias, sorte de raccourcis vers certaines parties des racines fondamentales.

- **`HKEY_CURRENT_USER (HKCU)`** contient la configuration du profil de l'utilisateur courant. Elle est un raccourci vers `HKU\SID_de_l'utilisateur`.
- **`HKEY_CLASSES_ROOT (HKCR)`** contient la configuration des classes de fichiers et de protocoles, issue de la superposition de `HKCU\SOFTWARE\Classes` et `HKLM\SOFTWARE\Classes`
- **`HKEY_CURRENT_CONFIG (HKCC)`** contient de l'information sur le profil mat√©riel du syst√®me. 


#### HKEY_CURRENT_USER (HKCU)

La cl√© racine `HKEY_CURRENT_USER`, ou `HKCU` en abr√©g√©, contient les donn√©es de configuration **propres √† l'utilisateur**. Chaque utilisateur poss√®de sa propre ruche. Ces donn√©es sont comprises dans le fichier `NTUSER`.DAT situ√© dans le profil utilisateur sous `C:\Users\`. 

L'utilisateur n'a pas besoin d'√™tre administrateur local pour √©crire ou modifier des valeurs dans cette ruche, puisque celle-ci appartient √† l'utilisateur.


#### HKEY_LOCAL_MACHINE (HKLM)

La cl√© racine `HKEY_LOCAL_MACHINE`, ou `HKLM` en abr√©g√©, contient les donn√©es de configuration **globales du syst√®me**. Ces configurations sont les m√™mes peu importe l'utilisateur connect√©.

On doit obligatoirement poss√©der des droits d'administration pour modifier les valeurs contenues dans cette ruche.

La plupart des param√®tres propres aux √©l√©ments logiciels (y compris les param√®tres du syst√®me d'exploitation) sont situ√©s dans la cl√© SOFTWARE.

:::tip
De nos jours, Windows est presque toujours install√© dans son √©dition 64 bits. Cependant, certaines applications plus vieilles ont √©t√© compil√©es pour une architecture de processeur 32 bits. Windows 10/11 et Windows Server poss√®dent un sous-syst√®me d'√©mulation permettant d'ex√©cuter des programmes 32 bits. Ce sous-syst√®me s'appelle "WoW64", pour "*Windows-on-Windows 64-bit*". 

Les fichiers des logiciels 32-bits install√©s dans une √©ditions 64-bits de Windows sont situ√©s dans le r√©pertoire `C:\Program Files (x86)\` (r√©f√©renc√© par la variable d'environnement `%ProgramFiles(x86)%`, ou `$env:{ProgramFiles(x86)}` en PowerShell). Leurs param√®tres dans le registre sont situ√©s sous la cl√© `HKLM\SOFTWARE\WOW6432Node\`.
:::

#### HKEY_USERS (HKU)

La cl√© racine `HKEY_USERS` (en abr√©g√© `HKU`) est une des racines fondamentales de Windows et comprend tous les utilisateurs qui ont une session ouverte.

La cl√© `.DEFAULT` repr√©sente le profil utilisateur du compte SYSTEM, et les autres cl√©s sont identifi√©es par le SID de l'utilisateur.

La ruche de l'utilisateur courant est accessible par `HKEY_CURRENT_USER`.

![](./assets/r08/hku.png)


#### HKEY_CLASSES_ROOT (HKCR)

La cl√© racine `HKEY_CLASSES_ROOT` (en abr√©g√© `HKCR`) contient la configuration des types de documents, d'extensions et des protocoles pris en charge par Windows. L'organisation de cette racine est assez complexe, mais essentielle √† Windows puisque c'est l√† qu'est rassembl√©e toute l'information qui permet √† Windows de savoir, par exemple, quelle application d√©marrer si on double-clique sur un fichier portant une extension, quelles sont les options disponibles dans le menu contextuel, etc.

Cette racine est en fait une combinaisaison de deux cl√©s:
- `HKEY_LOCAL_MACHINE\SOFTWARE\Classes` (la configuration syst√®me)
- `HKU\(sid)_CLASSES` (la configuration utilisateur)

Un param√®tre d√©fini dans la configuration utilisateur a pr√©s√©ance sur le m√™me param√®tre d√©fini dans la configuration syst√®me.

:::tip
La partie *Classes* du profil utilisateur n'est pas sauvegard√©e dans `%USERPROFILE%\NTUSER.DAT` comme le reste de sa ruche, elle est dans un fichier diff√©rent: `%LOCALAPPDATA%\Microsoft\Windows\UsrClass.dat`
:::


## Acc√®s au registre avec PowerShell

On peut facilement lire et √©crire des informations dans le registre de Windows via le fournisseur `Registry`.

### Obtenir la liste des sous-cl√©s d'une cl√©

On obtient la liste des sous-cl√© d'une cl√© avec la commande `Get-ChildItem`.

![](./assets/r08/reg_subkey1.png)

Pour voir seulement la liste des cl√©s, sans montrer aussi les valeurs qui y sont contenues, on peut ajouter le *switch* `-Name`.

![](./assets/r08/reg_subkey2.png)

### Tester si une cl√© existe

Pour tester si une cl√© existe, c'est tr√®s simple: il suffit d'utiliser `Test-Path`.

![](./assets/r08/reg_testkey.png)


### Cr√©er une cl√©

Pour cr√©er une nouvelle cl√©, on peut utiliser la commande `New-Item`.

```powershell
New-Item -Path "HKCU:\SOFTWARE\MaNouvelleCl√©"
```

![](./assets/r08/reg_newkey1.png)

Pour que √ßa fonctionne, la cl√© parente doit exister. On peut cependant sp√©cifier le switch `-Force` pour que l'arborescence de cl√© soit automatiquement cr√©√©e.

```powershell
New-Item -Path "HKCU:\SOFTWARE\UneCl√©\UneSousCl√©\UneSousSousCl√©" -Force
```

![](./assets/r08/reg_newkey2.png)

### Effacer une cl√©

Pour effacer une cl√©, il suffit d'utiliser la commande `Remove-Item`.

```powershell
Remove-Item -Path "HKCU:\SOFTWARE\MaNouvelleCl√©"
```

![](./assets/r08/reg_delkey.png)

Si cette cl√© contient des sous-cl√©s, on peut sp√©cifier le switch `-Recurse` pour effacer r√©cursivement toutes les sous-cl√©s.

```powershell
Remove-Item -Path "HKCU:\SOFTWARE\UneCl√©" -Recurse
```



### Obtenir les valeurs dans une cl√©

Pour obtenir toutes les valeurs dans une certaine cl√©, on peut utiliser la commande `Get-ItemProperty`.

![](./assets/r08/reg_val1.png)

Pour obtenir une valeur sp√©cifique, on peut utiliser la commande `Get-ItemPropertyValue` en sp√©cifiant la cl√© comme chemin et le nom de la valeur.

![](./assets/r08/reg_val2.png)

Il existe plusieurs autres mani√®res d'obtenir les donn√©es dans une valeur de registre. Voici quelques autres exemples:

![](./assets/r08/reg_val3.png)

On peut aussi utiliser la m√©thode `.GetValue()` d'une cl√©, comme le montre l'exemple ci-dessous:

![](./assets/r08/reg_val4.png)


### Tester si une valeur existe

Voici une mani√®re de tester si une valeur existe. Elle consiste √† rechercher toutes les valeurs dans la cl√© sp√©cifi√©e, puis filtrer pour ne ressortir que celle dont le nom correspond √† ce qu'on cherche. 

```powershell
Get-ItemProperty -Path "HKCU:\Unecl√©\" | Where-Object -Property "UnNomDeValeur"
```

Si le r√©sultat de cette ligne ne sort rien (donc `$null`), √ßa signifie que la valeur n'existe pas dans cette cl√©. Autrement, la commande donne quelque chose, donc n'est pas `$null`.

On peut int√©grer cette logique dans une condition.

```powershell
$CheminCl√© = "HKCU:\Chemin\vers\une\cl√©\"
$NomValeur = "MaValeur"

if (Get-ItemProperty -Path $CheminCl√© | Where-Object -Property $NomValeur) {
    # La valeur existe
}
else {
    # La valeur n'existe pas
}
```

Ou encore, √† l'inverse...

```powershell
$CheminCl√© = "HKCU:\Chemin\vers\une\cl√©\"
$NomValeur = "MaValeur"

if (-not (Get-ItemProperty -Path $CheminCl√© | Where-Object -Property $NomValeur)) {
    # La valeur n'existe pas
}
else {
    # La valeur existe
}
```

:::tip
Si la cl√© n'existe pas, Get-ItemProperty retournera une erreur. Pour masquer cette erreur, on peut sp√©cifier `-ErrorAction SilentlyContinue`

![](./assets/r08/reg_testval_error.png)
:::


### Cr√©er une valeur

Pour cr√©er une valeur dans le registre, on peut utiliser la commande `New-ItemProperty`.

Voici un exemple qui modifie la configuration du bloc-notes de Windows pour que la police de caract√®res soit "Comic Sans MS".

```powershell
$NewRegValSplat = @{
    Path = "HKCU:\SOFTWARE\Microsoft\Notepad\"
    Name = "lfFaceName"
    PropertyType = "String"
    Value = "Comic Sans MS"
}

New-ItemProperty @NewRegValSplat
```

Pour cr√©er une valeur num√©rique, il suffit de faire d√©finir le type √† "Dword".

```powershell
$NewRegValSplat = @{
    Path = "HKCU:\SOFTWARE\MonScript\"
    Name = "MaValeurNum√©rique"
    PropertyType = "Dword"
    Value = 123
}

New-ItemProperty @NewRegValSplat
```


### Modifier une valeur existante

Pour modifier une valeur de registre existante, on peut utiliser la commande `Set-ItemProperty`. La valeur doit d√©j√† exister pour que cette commande fonction

```powershell
$NewRegValSplat = @{
    Path = "HKCU:\SOFTWARE\Microsoft\Notepad\"
    Name = "lfFaceName"
    PropertyType = "String"
    Value = "Comic Sans MS"
}

New-ItemProperty @NewRegValSplat -Force
```

:::tip
Pour cr√©er une valeur si elle n'existe pas ou la modifier si elle existe, dans une seule commande, il suffit d'activer le param√®tre `-Force` de `New-ItemProperty`. Ceci va forcer la cr√©ation de la valeur, en l'√©crasant si elle existe

```powershell
$NewRegValSplat = @{
    Path = "HKCU:\SOFTWARE\MonScript\"
    Name = "MaValeurNum√©rique"
    PropertyType = "Dword"
    Value = 123
}

New-ItemProperty @NewRegValSplat
```
:::

### Effacer une valeur

Pour effacer une valeur de registre, on peut utiliser la commande `Remove-ItemProperty`.

![](./assets/r08/reg_delval.png)


## Streams

PowerShell utilise divers "*streams*" pour passer des objets. On conna√Æt d√©j√† le *stream* principal; c'est lui qu'on appelle le *pipeline* de PowerShell. On le qualifie √©galement de *stream* 1 et *stream* de sortie (*output stream*). Il y a d'autres *streams*, pour permettre la circulation d'autres types d'objets.

| # | Stream | Commande pour y √©crire | Description |
| - | ------ | ---------------------- | ----------- |
| 1 | Output / Success | `Write-Output` | C'est le pipeline principal. La commande `Write-Output` est facultative; tout objet qui r√©sulte d'une commande sans √™tre affect√© √† une variable tombe dans ce *stream*. |
| 2 | Error | `Write-Error` | C'est dans ce *stream* que circulent les erreurs, qui sont affich√©es en rouge avec de l'information suppl√©mentaire. |
| 3 | Warning | `Write-Warning` | On peut envoyer des messages d'avertissement dans ce *stream*. Ils seront affich√©s d'une autre couleur dans la console avec une mention d'avertissement. |
| 4 | Verbose | `Write-Verbose` | Ce *stream* est destin√© au texte de verbose. Un script ou une commande peut √©crire une sortie plus d√©taill√©e, qui est masqu√©e par d√©faut. Il faut activer la verbose pour le voir, soit avec le param√®tre `-Verbose` ou avec la variable `$VerbosePreference`.
| 5 | Debug | `Write-Debug` | Ce *stream* permet la circulation d'information de d√©bogage. Comme pour la verbose, ce qui y circule est cach√© par d√©faut. |
| 6 | Information | `Write-Information` | Ce *stream* permet la circulation d'information suppl√©mentaire pouvant aider au d√©veloppement. Comme pour la verbose, ce qui y est envoy√© est cach√© par d√©faut. `Write-Host`, tout en √©crivant du texte dans la console, envoie aussi une copie de ce texte dans le *stream* Information. |

Les diff√©rentes commandes `Write-____` permettent d'envoyer des objets dans un stream particulier.

```powershell
"Ceci est envoy√© dans le stream Output (le pipeline principal de PowerShell)."
Write-Output "Ceci est aussi envoy√© dans le stream Output (le pipeline principal de PowerShell)."
Write-Error "Ceci est envoy√© dans le stream Error, et sera √©crit en rouge avec des infos suppl√©mentaires."
Write-Warning "Ceci est envoy√© dans le stream Warning et sera √©crit en jaune avec une mention d'avertissement."
Write-Verbose "Ceci est envoy√© dans le stream Verbose et ne sera pas affich√© par d√©faut."
Write-Debug "Ceci est envoy√© dans le stream Debug et ne sera pas affich√© par d√©faut."
Write-Information "Ceci est envoy√© dans le stream Information et ne sera pas affich√© par d√©faut."
Write-Host "Ceci est √©crit directement dans la console, ainsi que dans le stream Information."
```

### Stream 1: Output / Success

Le stream Output est tout simplement le pipeline PowerShell que vous connaissez d√©j√†. C'est dans ce stream que les commandes produisent leurs objets de sortie. La commande Write-Output sert √† envoyer des objets dans ce stream, mais ce n'est pas n√©cessaire puisque tous les objets y circulent par d√©faut.



### Stream 2: Error

Le stream Error est le "pipeline" sur lequel les erreurs circulent. Les objets circulant dans ce stream sont ultimement convertis en texte pour son affichage dans la console, mais ce texte est format√© en rouge avec des informations sur l'erreur. 

![](./assets/r08/stream_error01.png)

On peut produire des erreurs avec la commande `Write-Error`.

![](./assets/r08/stream_error02.png)

Il est possible de cacher ou ignorer les erreurs et sp√©cifiant √† une commande une action en cas d'erreur. Par exemple, `-ErrorAction SilentlyContinue` fait en sorte que la sortie de ce stream ne sera pas affich√©e.

![](./assets/r08/stream_error03.png)

On peut aussi le faire globalement en modifiant la variable `$ErrorActionPreference`. Par d√©faut, l'action en cas d'erreur est "Continue", mais vous pouvez la changer pour "SilentlyContinue" pour que toutes les erreurs n'apparaissent pas dans la console. Notez que cette variable ne sera modifi√©e que pour la session PowerShell en cours.

![](./assets/r08/stream_error04.png)


:::info
Voici les valeurs d'action support√©es pour les erreurs. Ces actions sont sensiblement les m√™mes pour la pr√©f√©rence de traitement des autres streams.

| Action | Effet |
| -- | -- |
| Stop | Arr√™t imm√©diat du script ou de la fonction. |
| Continue | Le script ou la fonction affiche signale une erreur mais poursuit son ex√©cution (c'est le comportement par d√©faut pour les erreurs). |
| SilentlyContinue | Le script continue et n'affiche aucun message d'erreur, mais l'erreur est tout de m√™me envoy√©e dans le *stream*. |
| Ignore | Ignore les erreurs sans aucun signalement. (Cette valeur est inadmissible dans `$ErrorActionPreference`.) |
| Inquire | Le script affiche le message d'erreur et demande √† l'utilisateur s'il souhaite continuer ou arr√™ter. |
:::


### Stream 3: Warning

Ce stream est utilis√© pour √©crire des messages d'avertissement √† l'utilisateur. On pourrait le faire √† l'aide de Write-Host, mais le stream Warning offre la m√™me fonctionnalit√© que celui des erreurs: par le param√®tre `-WarningAction` ou une changement √† la variable `$WarningPreference`, qui est par d√©faut √† "Continue", on peut modifier le comportement en cas d'avertissement. Ainsi, en sp√©cifiant l'action "SilentlyContinue", les avertissements seront masqu√©s.

![](./assets/r08/stream_warning01.png)


### Stream 4: Verbose

Ce stream est utilis√© pour √©crire des messages d√©taill√©s, si l'utilisateur le souhaite. La commande pour y envoyer des messages est `Write-Verbose`. Les messages pass√©s dans ce stream sont masqu√©s par d√©faut, ce qui laisse l'impression que la commande ne fait rien. Comme pour les autres streams, il existe une variable qui contr√¥le si le message est affich√© ou non. Dans le cas du stream Verbose, cette variable est `$VerbosePreference` et sa valeur par d√©faut est "SilentlyContinue". On peut la changer √† "Continue" pour que l'affichage de ce stream soit envoy√© dans la console.

![](./assets/r08/stream_verbose01.png)

On n'utilisera pas vraiment cette technique, par contre. La raison pour laquelle on souhaiterait utiliser la commande Write-Verbose dans un script est pour afficher des messages d√©taill√©s optionnels, et permettre √† l'utilisateur qui appelle le script de sp√©cifier en param√®tre s'il veut afficher ces messages. PowerShell offre un m√©canisme pour √ßa.

Tout d'abord, on doit "transformer" le script en cmdlet. PowerShell ajoute √† toutes les commandes un certain nombre de param√®tres: ce sont les **param√®tres communs**. Simplement en ajoutant la mention `[CmdletBinding()]` au d√©but du script, juste avant le bloc `param()`, le script ou la fonction importera ces param√®tres communs.

![](./assets/r08/stream_cmdletbinding01.png)

Un des param√®tres commun est le switch `-Verbose`, et lorsqu'on le sp√©cifie, a pour effet d'activer la verbose pour le script.

![](./assets/r08/stream_verbose02.png)


:::tip
Si votre script est muni d'une fonction de logging, vous pouvez ajouter le m√™me message, moins le *timestamp*, dans le stream Verbose √† l'aide de la commande `Write-Verbose`. Vous ferez alors d'une pierre deux coups et ajouter ces deux op√©rations (l'√©criture √† un fichier et √† la verbose) dans votre fonction de log.
:::
