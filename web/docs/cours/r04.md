---
title: R04 - Param√®tres, fonctions, fichiers et strings
slug: "04"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 4 - Param√®tres, fonctions, fichiers et strings

:::note R√©sum√© de la s√©ance

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Rappel du cours pr√©c√©dent
1. Param√®tres et validations
1. Fonctions
1. Fichiers
    - Fichiers texte
    - Logging
    - Format CSV
1. Manipulation de cha√Ænes de caract√®res
    - EXTRA: Expressions r√©guli√®res (regex)

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

- Exercices sur OneNote

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::


## Les scripts et le pipeline

Lorsqu‚Äôil est d√©marr√© dans une session PowerShell, un fichier de script (.ps1) se comporte exactement comme une commande:
- Il retourne des objets sur le pipeline
- Il admet des objets en entr√©e du pipeline
- Il permet de sp√©cifier des arguments

Par exemple, voici un script `MonScript.ps1` situ√© dans le r√©pertoire `C:\Scripts`. 

```powershell
$reponse = Read-Host -Prompt "Entrez le nom d'un service"
$reponse | Get-Service   # Renvoie le service dans le pipeline
```

√Ä la fin de l'ex√©cution du script, un ou des objets sont envoy√©s sur le pipeline, r√©sultat de `Get-Service`. Ces objets sortent donc du script comme s'il s'agissait d'une commande. Si on ne fait rien avec, les objets sont convertis en texte et affich√©s dans la console, mais on peut les intercepter en cha√Ænant une autre commande dans le pipeline.

![image](./assets/r04/r06_01a.png)


## Param√®tres d'un script

Un script peut admettre un ou plusieurs param√®tres pour modifier son fonctionnement. On peut d√©clarer les param√®tres dans un bloc `param()`, qui doit se trouver obligatoirement **au tout d√©but** du script.

```powershell
param (
    [double] $Param1,
    [string] $Param2,
    [int[]]  $Param3,
    [switch] $Param4
)
```

On y d√©clare les param√®tres sous forme de variables typ√©es. Le nom de la variable repr√©sente le nom du param√®tre, et l'ordre de d√©claration des param√®tres devient sa position (lorsqu'on ne sp√©cifie pas son nom √† l'appel).

Lorsque le script sera appel√©, les arguments sp√©cifi√©s meubleront les variables qui leur sont associ√©es, et on pourra les utiliser dans le script.

Par exemple, ce script, `division.ps1` prend en param√®tre deux nombres, un dividende et un diviseur, effectue la division de ces deux nombres, et jette le r√©sultat dans le pipeline.

```powershell
param (
    [double]$Dividende,
    [double]$Diviseur
)

$Dividende / $Diviseur
```

![image](./assets/r04/r06_01b.png)

On remarquera aussi que PowerShell est conscient des param√®tres d√©clar√©s dans le script car il nous permet de les compl√©ter avec la touche de tabulation ou avec `Ctrl+Espace`.

![image](./assets/r04/r06_01c.png)


## Validation des param√®tres

Lorsqu'on d√©clare des param√®tres, il y a le risque que celui-ci soit mal utilis√©. Par exemple, qu'arrive-t-il si on appelle la fonction de division pour diviser "Chat" par trois? Qu'arrive-t-il si on demande de diviser un nombre par z√©ro?

Et surtout, qu'arrive-t-il si, dans un script assez long et qui effectue plusieurs t√¢ches, un param√®tre non conforme fait planter le script √† mi-chemin de son ex√©cution?

PowerShell nous offre diverses m√©thodes pour valider les param√®tres √† la source, afin de s'assurer que toutes les valeurs sont conformes √† ce qui est attendu avant de commencer son ex√©cution.


### Validation de type

Lorsqu'on sp√©cifie un type √† un param√®tre, le script valide d'abord si la valeur correspond au type attendu.

```powershell
param (
    [double] $Dividende,
    [double] $Diviseur
)

$Dividende / $Diviseur
```

Si la valeur attendue ne correspond pas au type du param√®tre, le script plante (et c'est ce qu'on veut; mieux vaut un script qui plante qu'un script qui fait n'importe quoi).

![image](./assets/r04/r06_01i.png)


### Crit√®res de validation

PowerShell offre, en plus de la validation de type, diff√©rents crit√®res de validation pour identifier au maximum les risques de valeurs ill√©gales sp√©cifi√©es en param√®tre.

Par exemple, si on souhaite √©viter que la fonction ou le script puisse √™tre appel√© avec un diviseur √©gal √† z√©ro, on peut ajouter un crit√®re de validation dans la d√©claration du param√®tre. Dans l'exemple suivant, on d√©finit un script qui, s'il est √©valu√© `False`, refusera d'ex√©cuter le code.

```powershell
param (
    [double] $Dividende,

    [ValidateScript( { $_ -ne 0 } )]
    [double] $Diviseur
)

$Dividende / $Diviseur
```

On peut clairement voir, √† l'analyse du message d'erreur, que le script ou la fonction a plant√© en raison d'un √©chec de validation du param√®tre `Diviseur`.

![image](./assets/r04/r06_01j.png)

Il existe plusieurs types de validation de param√®tre. En voici quelques exemples:

#### ValidateSet

La clause `ValidateSet` permet de s'assurer que la valeur pass√©e en param√®tre fait partie d'une liste de valeurs admissibles.

```powershell
param( 
    [ValidateSet('Rouge','Vert','Bleu‚Äô)]
    [string] $Couleur 
)

# Accepte seulement les cha√Ænes de caract√®res "Rouge", "Vert" ou "Bleu"
```

:::tip
Lorsqu'on utilise la clause `ValidateSet`, cela permet √† PowerShell d'√©num√©rer les valeurs admissibles lors de l'appel de la fonction ou du script, au moyen de la touche de tabulation ou de `Ctrl+Espace`.

![image](./assets/r04/r06_01k.png)
:::

#### ValidateRange

La clause `ValidateRange` permet de s'assurer qu'un nombre pass√© en param√®tre est situ√© entre deux valeurs inclusivement.

```powershell
param(
    [ValidateRange(7,120)]
    [Int] $Age
)

# Accepte un nombre entier de 7 √† 120 incl.
```

:::tip
`ValidateRange` exige de sp√©cifier les valeurs minimum et maximum. Mais lorsqu'on souhaite seulement sp√©cifier une valeur maximum ou minimum, on peut faire appel aux propri√©t√©s MaxValue et MinValue du type en question.

Par exemple, pour attendre un nombre de type `[int]` de 7 ou plus, il suffit de sp√©cifier un *range* de 7 √† la valeur maximale du type `[int]`, soit `[int]::MaxValue`.

```powershell
param(
    [ValidateRange(7, [int]::MaxValue)]
    [Int] $Age
)

# Accepte un nombre entier de 7 ou plus.
```
:::


#### ValidateLength

La clause `ValidateLength` valide la taille minimum et maximum d'une cha√Æne de caract√®res.

```powershell
param(
    [ValidateLength(0,15)]
    [String] $NoTel
)

# Accepte une cha√Æne de 0 √† 15 caract√®res incl.
```


#### ValidateCount

La clause `ValidateCount` valide le nombre d'√©l√©ments minimum et maximum d'une collection d'objets pass√©e en param√®tre.

```powershell
param(
    [ValidateCount(1,5)]
    [String[]] $ComputerName
)

# Accepte un tableau de 1 √† 5 √©l√©ments incl.
```

#### ValidateScript

La clause `ValidateScript` est la plus versatile et peut √™tre utilis√©e pour les validations plus complexes qui ne peuvent √™tre faites par les autres m√©thodes. Elle permet de sp√©cifier un script √† ex√©cuter avec la valeur pass√©e en param√®tre (repr√©sent√©e par la variable pipeline `$_`). Si le script retourne `True`, l'argument est valid√©; s'il retourne `False`, la validation √©choue et le script plante.

```powershell
param(
    [ValidateScript( { Test-Path $_ } )]
    [String] $Path
)

# Permet de cr√©er un script qui retourne vrai ou faux. Si faux, le param√®tre est rejet√©.
```

### Param√®tres obligatoires

Par d√©faut, tous les param√®tres sont optionnels. S'ils ne sont pas sp√©cifi√©s lors de l'appel de la fonction ou du script, alors ils prennent automatiquement leur valeur neutre.

- La valeur 0 pour les types num√©riques (`int`, `double`...)
- Une cha√Æne vide (`""`) pour le type `string`
- Une valeur nulle (`$null`) pour les collections
- etc.

Pour s'assurer qu'un param√®tre soit sp√©cifi√© √† l'appel de la fonction ou du script, on peut ajouter un bloc `[Parameter()]` √† la d√©claration du param√®tre. Ce bloc permet de d√©finir certaines propri√©t√©s du param√®tre. Pour rendre le param√®tre obligatoire, il faut activer la propri√©t√© Mandatory du param√®tre.

```powershell
function Soustraction {
    param(
        [Parameter(Mandatory)]
        [double] $op1,

        [Parameter(Mandatory)]
        [double] $op2
    )

    $op1 - $op2
}
```

Si un param√®tre obligatoire n'est pas sp√©cifi√©, le script refusera de s'ex√©cuter. √Ä la place, il demandera √† l'utilisateur de sp√©cifier les param√®tres manquants √† la ligne de commande. L'appelant peut alors soit saisir manuellement l'argument manquant, soit annuler l'ex√©cution du script avec les touches `Ctrl+C`.

![image](./assets/r04/r06_01l.png)


### Valeur par d√©faut d'un param√®tre

Une alternative √† rendre obligatoire un param√®tre consiste √† lui attribuer une valeur par d√©faut. Ainsi, ce param√®tre prendra automatiquement la valeur sp√©cifi√©e si l'utilisateur ne le sp√©cifie pas √† l'appel du script ou de la fonction.

Par exemple, voici le script `Arrondir.ps1`.

```powershell
Param(
    [Parameter(Mandatory)]
    [double] $Nombre,

    [int] $Decimales = 2
)

[Math]::Round($Nombre, $Decimales)
```

La valeur du param√®tre `Decimales` prend la valeur 2 √† moins d'√™tre sp√©cifi√©e explicitement.

![image](./assets/r04/r06_01m.png)


### Param√®tres de type Switch

Les param√®tres de type Switch prennent une valeur bool√©enne (vraie ou fausse) selon qu'ils soient sp√©cifi√©s ou non. On les identifie avec le type [switch].

```powershell
param (
    [Parameter(Mandatory)]
    [double] $op1,
    
    [Parameter(Mandatory)]
    [double] $op2,
    
    [switch] $Miauler
)

$op1 - $op2

if ($Miauler) {
    Write-Host "Miaou!"
}
```

### Param√®tres de type collection

Il est possible de faire en sorte qu'un param√®tre admette plus d'une valeur. Il suffit de faire de son type une collection. Si par exemple, on souhaite que le param√®tre permette de passer une ou plusieurs valeurs enti√®res, on va donner au param√®tre le type `[int[]]`, soit un tableau d'entier.

```powershell
param ( 
    [int[]] $Nombres 
)

$total = 0

foreach ($nombre in $Nombres) {
    $total += $nombre
}

# On renvoie le total dans le pipeline!
$total    
```

:::tip
Les param√®tres qui admettent un tableau de valeurs se combinent tr√®s bien avec la clause de validation `[ValidateCount()]`, pour sp√©cifier un nombre minimum et maximum d'√©l√©ments dans le tableau.
:::


### Entr√©e par le pipeline

On peut permettre √† une fonction ou un script de traiter l'entr√©e du pipeline.

Par exemple, le script Saluer.ps1 accepte deux param√®tres, un nom et un titre. Mais lorsqu'une valeur admissible entre par le pipeline, celle-ci entrera dans le param√®tre Nom.

```powershell
Param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [string] $Nom,

    [ValidateSet("M.","Mme.","Mlle.","Dr.","Me.")]
    [string] $Titre
)

"Bonjour, $Titre $Nom!"
```

De cette mani√®re, le param√®tre Nom peut soit √™tre sp√©cifi√© par le param√®tre, soit par l'entr√©e du pipeline. Dans les deux cas, l'effet est le m√™me.

![image](./assets/r04/r06_01n.png)




## Fonctions

Une fonction PowerShell est un bloc de script qu'on enregistre dans la session en cours. On doit la d√©clarer en lui donnant un nom, et √† l'instar d'un fichier de script, elle se comporte exactement comme un script ou une commande.

Pour d√©clarer une fonction, on utilise le mot-cl√© `function` suivi de son nom, et on d√©finit le code de la fonction entre des accolades. Il est recommand√© d'indenter le contenu de la fonction.

```powershell
function Get-Zero {
    0
}
```

:::caution
La d√©claration d'une fonction n'a d'effet que dans la session en cours. Apr√®s l'ex√©cution du script ou apr√®s fermeture de la fen√™tre PowerShell, celle-ci n'existe plus et il faudra la d√©clarer √† nouveau si on veut l'utiliser.
:::

:::tip
On peut obtenir la liste de toutes les fonctions qui sont d√©clar√©es dans la session PowerShell en cours √† l'aide de la commande `Get-ChildItem Function:`.

![image](./assets/r04/r06_01g.png)
:::

L'exemple ci-dessus montre la fonction d√©clar√©e sous le nom de `Get-Zero`, et qui sert simplement √† obtenir la valeur 0. Celle-ci ne fait qu'envoyer l'objet `0` (un nombre entier) dans le pipeline, afin que cette valeur soit r√©cup√©r√©e √† la sortie de la fonction.

![image](./assets/r04/r06_01f.png)


### Sortie dans le pipeline

Une fonction (tout comme un script, d'ailleurs), dispose en quelque sorte d'un "accumulateur" qui contient tous les objets qui tombent dans le pipeline. √Ä la sortie de la fonction, les objets sortent sous forme de collection.

```
function Get-CrisDAnimaux {
    "Miaou!"
    "Wouf!"
    "Cocorico!"
}
```

Cette fonction laisse tomber trois objets `String` dans le pipeline. Ceux-ci sortent sous forme de collection. C'est la m√™me chose avec un fichier PS1.

![image](./assets/r04/r06_01h.png)


### Instruction *Return*

L'instruction `return` permet de sortir un objet sur le pipeline tout en interrompant imm√©diatement l'ex√©cution de la fonction. 

```powershell
function Get-Zero {
    return 0
    Write-Host "Ce texte ne sera jamais √©crit!"
}
```

:::info
Dans un script, on utilise souvent une fonction lorsque du code se r√©p√®te souvent, pour √©viter de copier-coller le m√™me code √† plusieurs endroits dans le script. Une fonction doit obligatoirement √™tre d√©finie avant d'√™tre appel√©e, mais il est une bonne pratique de d√©clarer toutes les fonctions au d√©but du script, juste apr√®s le bloc de param√®tres, mais avant le code principal du script.
:::

### Param√®tres de fonction

Une fonction et un script `.PS1` se comportent comme une commande PowerShell. L'un est enregistr√© dans la session en cours, l'autre est d√©fini sous forme de fichier. Mais dans les deux cas, on peut leur d√©finir des param√®tres au moyen d'un bloc `param()`.

Par exemple, le script `Division.ps1` vu pr√©c√©demment aurait pu, √† la place, √™tre d√©fini comme une fonction.

```powershell
function Division {
    param (
        [double] $Dividende,
        [double] $Diviseur
    )

    $Dividende / $Diviseur
}
```




## Fichiers

Un **fichier** est une unit√© logique de stockage de donn√©es, contenue sur un **volume** (aussi appel√© **disque logique**). Un volume, sous Windows, est g√©n√©ralement identifi√© par une lettre (C:, D:, etc.) et occupe une r√©gion plus ou moins grande sur un m√©dium physique de stockage. Sur un disque dur, cette r√©gion se nomme une **partition**. Pour pouvoir stocker les fichiers, un volume doit √™tre **format√©** dans un **syst√®me de fichiers**, qui d√©termine la structure des fichiers et des r√©pertoires ainsi que des fonctionnalit√©s connexes (s√©curit√©, taille de blocs, r√©silience, m√©tadonn√©es, etc.). Les syst√®mes de fichiers les plus r√©pendus sous Windows sont *NTFS*, *FAT32*, *ExFAT* ou *ReFS*, alors que les plus r√©pendus sous Linux sont *Ext4* et *ZFS*. 

Certains volumes sont stock√©s sur un syst√®me distant, et sont accessibles par le biais d'un protocole de partage de fichiers sur le r√©seau (par exemple, SMB sous Windows, NFS sous Linux). On les appelle les volumes r√©seaux, ou lecteurs r√©seaux (*network drive*), par opposition aux volumes locaux, ou lecteurs locaux (*local drives*), qui sont directement connect√©s √† l'ordinateur.

Un syst√®me de fichiers poss√®de typiquement une table d'allocation, une sorte de table des mati√®res qui dispose chaque fichier dans l'arborescence et indique √† quel endroit de la surface du m√©dium les donn√©es comprises dans le fichier se trouvent physiquement. Ces donn√©es sont simplement une suite d'octets, et le format de fichier permet √† un programme de lire le fichier et interpr√©ter correctement ces octets. Sous Windows, l'extension du nom du fichier aide le syst√®me d'exploitation et les applications √† savoir quel est le format du fichier et comment interpr√©ter ses donn√©es.

Il existe deux grandes cat√©gories de fichiers:
- Les fichiers **texte**, dont les octets encodent des caract√®res en utilisant une table de caract√®res standardis√©e telle que UTF-8 ou ANSI. C'est le cas des fichiers TXT, PS1, JSON, HTML, CSV, etc.

    ![image](./assets/r04/r07_00a.png)

- Les fichiers **binaires**, qui contiennent des donn√©es num√©riques brutes. C'est le cas des fichiers ZIP, JPG, PNG, DOCX, XLSX, etc.

    ![image](./assets/r04/r07_00b.png)

PowerShell offre plusieurs commandes pour traiter avec des fichiers de diff√©rents formats.


### Navigation dans le syst√®me de fichiers

Vous connaissez d√©j√† la commande `Get-ChildItem`. C'est un peu l'√©quivalent de DIR dans l'invite de commandes classique. Cette commande, lorsqu'elle est lanc√©e sur le syst√®me de fichiers, retourne le contenu d'un r√©pertoire.

Nous avons d√©j√† dit que `Get-ChildItem`, lorsqu'il retourne plusieurs objets, retourne un tableau d'objets. Comme les fichiers et les dossiers sont des structures diff√©rentes, et que ces deux types d'objets peuvent se retrouver dans un m√™me tableau, le tableau est donc constitu√© de deux types d'objets:

- Chaque fichier est de type `System.IO.FileInfo`
- Chaque r√©pertoire est de type `System.IO.DirectoryInfo`

On peut aussi utiliser la commande `Get-Item` pour obtenir l'objet qui repr√©sente un fichier ou un r√©pertoire, contrairement √† `Get-ChildItem` qui retourne plusieurs objets enfants.


### Fichiers texte

Il est tr√®s fr√©quent qu'un script doive lire dans un fichier. Un usage typique de lecture d'un fichier texte est pour traiter des entr√©es multiples.

Par exemple, votre employeur vient de faire l'acquisition d'une entreprise concurrente, et votre patron vous demande de cr√©er des comptes utilisateurs pour chacun des 3000 employ√©s vis√©s par l'acquisition. La mani√®re la plus simple de proc√©der est de faire un script qui lit un fichier contenant les informations de chacun des employ√©s ligne par ligne.

La principale commande pour lire un fichier est `Get-Content`.

![image](./assets/r04/r07_01a.png)

`Get-Content` lit le fichier ligne par ligne. Donc, cette commande retourne un tableau de string.

![image](./assets/r04/r07_01b.png)

On peut facilement traiter le fichier dans une boucle.

![image](./assets/r04/r07_01c.png)

Ou par un filtre.

![image](./assets/r04/r07_01d.png)

Et on peut passer un fichier par le pipeline.

![image](./assets/r04/r07_01e.png)

Et faire toutes les manipulations souhait√©es.

```powershell
Get-Item -Path ".\Utilisateurs.txt" | Get-Content | Where-Object { $_ -like 'A*' } | ForEach-Object {
    $split = $_.Split(',')
    [PSCustomObject]@{
        Nom = $split[0]
        Tel = $split[1]
    }
} | Sort-Object | Format-Table
```

Pour √©crire dans un fichier, vous pouvez utiliser plusieurs commandes.

La commande `Out-File` exporte un objet vers un fichier. Tout ce qui entre dans cette commande par le pipeline sera sortie vers un fichier, ce qui implique une conversion en texte. Si le fichier de destination n'existe pas, il sera automatiquement cr√©√©.

On peut activer le switch `-Append` si on veut que les objets soient ajout√©s √† la fin du fichier s'il existe d√©j√†, sinon le contenu sera remplac√©.

![image](./assets/r04/r07_01g.png)

On peut aussi sp√©cifier divers encodages.

![image](./assets/r04/r07_01h.png)

Si le fichier n'existe pas, il sera cr√©√© automatiquement. Si on souhaite plut√¥t que le script plante si le fichier existe d√©j√†, on peut activer le switch `-NoClobber`.

Alternativement, les commandes `Set-Content` et `Add-Content` √©crivent du contenu dans un fichier texte. Si le fichier n'existe pas, il sera automatiquement cr√©√©. Son fonctionnement est tr√®s semblable √† celui de `Out-File`, et dans la majorit√© des cas, on peut utiliser l'une ou l'autre des m√©thodes.

- La commande `Set-Content` **remplace** le contenu du fichier.
- La commande `Add-Content` **ajoute** le contenu √† la fin du fichier.

![image](./assets/r04/r07_01i.png)


### Fichiers CSV

Un fichier CSV (pour Comma Separated Values) est un fichier texte o√π chaque valeur est d√©limit√©e par une virgule (ou un point-virgule dans les r√©gions o√π les d√©cimales sont repr√©sent√©es par des virgules et non des points). 

![image](./assets/r04/r07_01j.png)

C'est un format utilis√©, entre autres, pour importer des donn√©es dans Excel. En effet, le contenu du fichier CSV peut facilement √™tre vu comme un tableau compos√© de champs (colonnes) et de rang√©es. La premi√®re ligne d√©signe le titre des colonnes.

Pour lire un fichier CSV, on peut utiliser la commande `Import-CSV`. Permet de transformer le contenu d'un fichier CSV en tableau de PSCustomObject.

![image](./assets/r04/r07_01k.png)

Pour √©crire un fichier CSV √† partir d'une structure de donn√©es (comme un tableau d'objets), on fait appel √† `Export-Csv`.

![image](./assets/r04/r07_01l.png)

Finalement, les commandes `ConvertTo-Csv` et `ConvertFrom-Csv` sont comme les commandes `Export-Csv` et `Import-Csv`, mais au lieu de travailler avec les fichiers CSV, elles travaillent avec des cha√Ænes de caract√®res CSV. C'est pratique dans certains cas, si on veut envoyer les donn√©es CSV dans une base de donn√©es ou sur le r√©seau.

![image](./assets/r04/r07_01m.png)

![image](./assets/r04/r07_01n.png)

:::info Note
Par d√©faut, lorsque PowerShell produit du texte format√© en CSV, une ligne #TYPE s'ajoute automatiquement au d√©but du fichier. Cette ligne n'est pas reconnus par plusieurs logiciels traitant avec des fichiers CSV, comme Excel. Pour l'enlever, il suffit d'activer le switch `-NoTypeInformation` lors de l'appel de `Export-Csv` ou `ConvertTo-Csv`.

![image](./assets/r04/r07_01o.png)
:::

#### D√©limiteur

Il faut faire attention au d√©limiteur. Souvent c'est la virgule, mais dans certaines r√©gions, c'est autre chose. En fran√ßais, comme la virgule est d√©j√† utilis√©e comme s√©parateur d√©cimale, par d√©faut c'est le point-virgule qui est utilis√©. Ainsi, sur une machine configur√©e en fran√ßais, lorsqu'on tente d'importer un CSV produit sur une machine en anglais, Excel n'arrive pas √† s√©parer les colonnes. 

On peut conna√Ætre le caract√®re utilis√© par Windows pour s√©parer les listes par l'interface graphique ou encore gr√¢ce √† `Get-Culture`.

![image](./assets/r04/r07_01q.png)

```powershell
(Get-Culture).TextInfo.ListSeparator
```

PowerShell prend toujours la virgule par d√©faut, peu importe la langue du syst√®me, contrairement √† Excel qui prend le s√©parateur de liste d√©fini dans les options r√©gionales.

- Pour prendre le caract√®re de s√©paration d√©fini dans les options r√©gionales, il faut utiliser le switch `-UseCulture`.
- Pour sp√©cifier le caract√®re de s√©paration, on peut le faire avec le param√®tre `-Delimiter` et lui passer un caract√®re en argument.

![image](./assets/r04/r07_01p.png)


### Fichiers JSON

PowerShell offre aussi des commandes qui permettent de convertir des objets en JSON et vice-versa. Il n'existe toutefois pas de commandes d'exportation et d'importation comme pour les CSV; il faut alors proc√©der en deux √©tapes.

Pour lire un fichier JSON et le convertir en une structure complexe de listes et de dictionnaires, on peut r√©cup√©rer le texte brut du fichier avec `Get-Content`, puis passer le r√©sultat par le pipeline dans la commande `ConvertFrom-Json`.

```powershell
$canadiens = Get-Content -Path ".\canadiens.json" | ConvertFrom-Json
```

Pour √©crire une structure dans un fichier JSON, il suffit de passer l'objet par le pipeline dans `ConvertTo-Json` puis √©crire le r√©sultat dans un fichier √† l'aide de `Set-Content` ou `Out-File`.

```powershell
$canadiens | ConvertTo-Json | Set-Content -Path ".\canadiens.json"
```

:::info Note
Lorsque vous tentez de convertir en JSON des objets complexes, vous pouvez pr√©ciser le niveau de profondeur de la conversion en JSON √† l'aide du param√®tre `-Depth`.
:::


### Journalisation

Il est g√©n√©ralement une bonne pratique de programmer nos scripts de telle sorte qu'ils documentent leur d√©roulement dans un fichier journal (ou log). Ainsi, lorsqu'on suspecte qu'un script a failli √† sa t√¢che, on peut se r√©f√©rer au fichier log pour investiguer les causes de la d√©faillance.

#### Format

Un fichier log type est en format texte brut et porte l'extension .log. Chaque fois que le script rencontre une action importante au cours de son ex√©cution, il ajoute une ligne √† la fin du fichier pour documenter cette action. Chaque ligne est horodat√©e avec pr√©cision afin de d√©celer d'√©ventuelles lenteurs dans l'ex√©cution d'une action.

:::info Note
Certains logs adoptent un format particulier, qui correspondent √† un outil qui en facilite la lecture. Par exemple, SCCM produit ses logs dans un format difficilement lisible avec un √©diteur de texte, mais parfaitement adapt√©s √† l'outil CMtrace, qui vient avec. 
:::

#### Niveau de d√©tail

Les logs peuvent √™tre tr√®s d√©taill√©s ou tr√®s sommaires, d√©pendant du besoin et de la criticit√© du service impact√©. Il est m√™me possible de permettre diff√©rents niveaux de verbosit√©, au besoin. 

#### Emplacement du fichier log

Il est important de sauvegarder le fichier log √† un endroit judicieux. Il n'est habituellement pas recommand√© de le sauvegarder dans le r√©pertoire de travail, puisque celui-ci tend √† √™tre impr√©visible. De plus, il n'est pas toujours appropri√© de choisir le r√©pertoire sur lequel le script est ex√©cut√©, puisque rien ne garantit que l'utilisateur poss√®de des droits d'√©criture √† cet emplacement, particuli√®rement si le script n'a pas besoin de privil√®ges d'administration.

G√©n√©ralement, on choisit un emplacement o√π l'on sait que l'utilisateur poss√®de des droits d'√©criture. On privil√©gie donc les emplacements √† l'int√©rieur du profil de l'utilisateur, comme ceux repr√©sent√©s par les variables d'environnement `LOCALAPPDATA`, `APPDATA` ou `TMP`.

Il n'est pas rare que l'emplacement du fichier journal puisse √™tre d√©finie par un param√®tre.

#### Activation du log

Plusieurs scripts utilisent un param√®tre pour activer la journalisation. Il peut s'agir d'un param√®tre de type Switch, ou encore simplement d'un param√®tre qui permet de sp√©cifier le nom du fichier log (s'il n'est pas sp√©cifi√©, la journalisation est d√©sactiv√©e).

#### Rotation

La taille des fichiers log est un probl√®me commun. En effet, les fichiers log peuvent prendre une taille consid√©rable avec le temps. Il est donc important de prendre ce fait en consid√©ration, particuli√®rement si le script est tr√®s verbeux.

La strat√©gie classique consiste √† d√©finir une taille maximale au fichier log (par exemple, 10 Mo). D√®s que cette taille sera atteinte, le fichier est renomm√© diff√©remment (par exemple, `journal.log` est renomm√© en `journal.lo_`). Et si le fichier `journal.lo_` existe d√©j√†, il est d√©truit pour laisser la place au nouveau `journal.lo_`.


### Fichiers Zip

PowerShell offre la possibilit√© de compresser ou d√©compresser des fichiers. Les commandes sont `Compress-Archive` et `Expand-Archive`.

Cependant, ces commandes souffrent d'une tr√®s mauvaise performance. On peut am√©liorer nettement la performance en faisant appel aux m√©thodes de *.NET Framework*.

```powershell
# D√©clarer la classe .NET offrant les m√©thodes de compression
Add-Type -Assembly "System.IO.Compression.Filesystem"

# Pour compresser
[System.IO.Compression.ZipFile]::CreateFromDirectory("C:\vers\RepertoireSource","C:\vers\destination.zip")

# Pour d√©compresser
[System.IO.Compression.ZipFile]::ExtractToDirectory("C:\vers\source.zip", "C:\vers\RepertoireDestination") }
```


### S√©curit√©

On peut utiliser PowerShell pour consulter et modifier les listes d'acc√®s aux fichiers.

![image](./assets/r04/r07_01v.png)

Il existe plusieurs mani√®re d'obtenir les listes d'acc√®s avec PowerShell.

Les objets de type `FileInfo` et `DirectoryInfo` poss√®dent une m√©thode `GetAccessControl()`, qui retourne un objet de type `System.Security.AccessControl.FileSecurity` (ou `System.Security.AccessControl.DirectorySecurity`, pour les r√©pertoires). 

![image](./assets/r04/r07_01w.png)

Cet objet contient l'information de s√©curit√© de ce fichier ou dossier.

On peut aussi obtenir ce m√™me objet avec la commande `Get-Acl`.

```powershell
Get-Item -Path "C:\Users\Administrator\Desktop\MonFichier.txt" | Get-Acl
  # ou
Get-Acl -Path "C:\Users\Administrator\Desktop\MonFichier.txt"
```

Dans tous les cas, l'objet retourn√© est le m√™me.

On peut obtenir les propri√©t√©s que l'on peut interroger sur l'objet de type FileSecurity. 

![image](./assets/r04/r07_01x.png)

Vous pouvez, par exemple, obtenir les acc√®s au fichier ou au dossier avec la propri√©t√© Access.

![image](./assets/r04/r07_01y.png)

Vous pouvez aussi obtenir l'information sur le propri√©taire, et ce, de deux mani√®res diff√©rentes.

Par la propri√©t√© Owner (√ßa retourne un String)

![image](./assets/r04/r07_01z.png)

Par la m√©thode GetOwner (√ßa retourne un objet plus utile)

![image](./assets/r04/r07_01aa.png)

Voir la documentation pour les classes:
https://docs.microsoft.com/en-us/dotnet/api/system.security.accesscontrol.filesecurity
https://docs.microsoft.com/en-us/dotnet/api/system.security.accesscontrol.directorysecurity



#### Modifier des permissions

Modifier des permissions est un peu plus complexe que les lire. On peut modifier la table de permissions d'un fichier √† l'aide de la commande `Set-Acl`.

`Set-Acl` permet de modifier la table de permissions d'un item. Comme la plupart des commandes dont le verbe est Set, cette commande remplace la table de permissions existante par une nouvelle.

Lorsqu'on veut modifier la table de permissions d'un fichier ou d'un dossier, on doit:

1. Obtenir un objet repr√©sentant la table de permissions (une copie), gr√¢ce √† `Get-Acl`
2. Modifier cet objet √† notre guise
3. Remplacer la table de permission existante par notre copie modifi√©e, avec `Set-Acl`

Dans l'exemple ci-dessous, on veut ajouter une permission de contr√¥le total pour l'utilisateur *yvon.rocher* dans le r√©pertoire *C:\Plouc\\*.

```powershell
# Premi√®rement, on cr√©e une nouvelle r√®gle d'acc√®s
$Identity = "yvon.rocher"
$FileSystemRights = "FullControl"
$InheritanceFlags = "ContainerInherit,ObjectInherit"
$PropagationFlags = "None"
$AccessControlType = "Allow"

$Rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
    $Identity, $FileSystemRights, $InheritanceFlags, $PropagationFlags, $AccessControlType
)

# On obtient une copie de la table de permissions du dossier
$Path = "C:\Plouc"
$ACL = Get-Acl -Path $Path

# On ajoute la nouvelle r√®gle √† la copie de la table de permissions
$ACL.AddAccessRule($Rule)

# Finalement, on remplace la liste d'acc√®s du dossier par notre nouvelle r√®gle modifi√©e
Set-ACL -Path $Path -AclObject $ACL
```









## Manipulation de cha√Ænes de caract√®res

Les cha√Ænes de caract√®res sont des objets de type `[String]` qui poss√®dent un certain nombre de m√©thodes, qu'on peut obtenir √† l'aide de la commande `Get-Member`. En plus des m√©thodes offertes par ce type, PowerShell offre un bon nombre de commandes et d'op√©rateurs permettant de les manipuler.

### Concat√©nation

La concat√©nation est une op√©ration consistant √† cr√©er une cha√Æne de caract√®res par la combinaison de plusieurs cha√Ænes de caract√®res plus petites.

```powershell
$prenom = "Yvon"
$nom = "Rocher"

"Bonjour $prenom $nom!"
#retourne: "Bonjour Yvon Rocher!"

"Bonjour {0} {1}!" -f $prenom $nom
#retourne: "Bonjour Yvon Rocher!"

"Bonjour " $prenom + " " + $nom + "!"
#retourne: "Bonjour Yvon Rocher!"

[String]::Concat("Bonjour ",$prenom," ",$nom,"!")
#retourne: "Bonjour Yvon Rocher!"
```

### Nettoyage

Il arrive que des cha√Ænes de caract√®res comprennent des espaces de trop au d√©but ou √† la fin. Les m√©thodes `Trim()`, `TrimStart()` et `TrimEnd()` les √©liminent.

```powershell
$miaou = "          miaou          "  # 10 espaces avant et apr√®s

"[" + $miaou.Trim() + "]"
#retourne: "[miaou]"

"[" + $miaou.TrimStart() + "]"
#retourne: "[miaou          ]"

"[" + $miaou.TrimEnd() + "]"
#retourne: "[          miaou]"
```

### Padding

Le padding est une op√©ration qui consiste √† ajouter des espaces au d√©but ou √† la fin d‚Äôune cha√Æne.

Les m√©thodes `PadRight(<n>)` et `PadLeft(<n>)` permettent d‚Äôajouter assez d‚Äôespaces √† droite ou √† gauche pour que la longueur totale de la cha√Æne soit de `n`.

```powershell
$pitou = "Wouf!"

"["+ $pitou.PadLeft(10) +"]"
#retourne: "[     Wouf!]" (5 espaces avant + 5 caract√®res = 10)

"["+ $pitou.PadRight(10) +"]"
#retourne: "[Wouf!     ]" (5 caract√®res + 5 espaces apr√®s = 10)
```

### Fractionnement (split)

La m√©thode `Split()` permet s√©parer une cha√Æne en plusieurs morceaux. Elle produit donc un array de cha√Ænes plus petites, s√©par√©es par un d√©limiteur commun. Le d√©limiteur par d√©faut est l‚Äôespace, mais on peut en sp√©cifier un en param√®tre.

```powershell
$fruits = "pomme banane kiwi"
$fruits.Split()
#retourne un array contenant les cha√Ænes "pomme", "banane" et "kiwi"

$legumes = "oignon;carotte;celeri"
$legumes.Split(';')
#retourne un array contenant les cha√Ænes "oignon", "carotte" et "celeri"
```

On peut aussi sp√©cifier le nombre maximum de fractions.

```powershell
$legumes = "oignon;carotte;celeri"
$legumes.Split(';',2)
#retourne un array contenant les cha√Ænes "oignon" et "carotte;celeri"
```

Comme le r√©sultat de la m√©thode `Split()` retourne un *array*, on peut le manipuler comme n'importe quelle collection. Voici un exemple:

```powershell
$fruits = "pomme banane kiwi"
$tabFruits = $fruits.Split()

$tabFruits[1]
#retourne la cha√Æne: "banane"

$tabFruits | Where-Object { $_ -like "b*" } | Write-Host -ForegroundColor Yellow
#√©crit "banane" en jaune dans la console.
```

### Extraction

On peut extraire une partie d'une cha√Æne de caract√®res √† l'aide de la m√©thode `Substring()`. 

Cette m√©thode prend deux param√®tres:
- Le premier d√©signe le point de d√©part (le premier caract√®re est 0)
- Le deuxi√®me d√©signe le nombre de caract√®res √† l'inclure

```powershell
"Lorem ipsum".Substring(2,3)
# Retourne les 3 caract√®res √† partir du caract√®re #2, soit "rem".
```

Suivant la m√™me logique, la m√©thode `Remove()` permet de retirer une partie de la cha√Æne.

```powershell
"Lorem ipsum".Remove(2,3)
# Retourne la cha√Æne sans les 3 caract√®res √† partir du caract√®re #2, soit "Lo ipsum".
```


### Remplacement

La m√©thode `Replace()` permet de remplacer toutes les occurrences d'une cha√Æne dans une autre.

Cette m√©thode prend deux param√®tres:
- Le premier d√©signe le texte √† remplacer
- Le deuxi√®me d√©signe le texte de remplacement

```powershell
"Lorem ipsum".Replace("m","che")
# Retourne "Loreche ipsuche"
```

### Recherche

La m√©thode `IndexOf()` retourne le num√©ro du caract√®re (le premier √©tant 0) o√π d√©bute un certain texte. Cette m√©thode retourne uniquement la position de la premi√®re occurrence, mais on peut sp√©cifier un point de d√©part; dans ce cas, elle retourne la premi√®re occurrence √† partir de cette position.

```powershell
"Lorem ipsum".IndexOf("m")
#retourne: 4

"Lorem ipsum".IndexOf("m",6)
#retourne: 10
```

### Comparaison

PowerShell offre d√©j√† les op√©rateurs `-eq`, `-ieq` et `-ceq` pour comparer les cha√Ænes de caract√®res.
- Les op√©rateurs `-eq` (sous Windows) et `-ieq` ignorent la casse.
- L‚Äôop√©rateur `-ceq`, lui, est sensible √† la casse.

```powershell
"Lorem ipsum" -eq "lorem ipsum"
#retourne: True

"Lorem ipsum" -ieq "lorem ipsum"
#retourne: False
```

On peut aussi utiliser la m√©thode `Equals()`.
- Par d√©faut, elle est sensible √† la casse.
- On peut sp√©cifier 1 au deuxi√®me param√®tre pour qu'elle ignore la casse.

```powershell
"Lorem ipsum".Equals("lorem ipsum")
#retourne: False

"Lorem ipsum".Equals("lorem ipsum",1)
#retourne: True
```

### Correspondance

Pour savoir si une cha√Æne contient une autre cha√Æne, on peut utiliser la m√©thode `Contains()`.

```powershell
"Lorem ipsum".Contains("rem")
#retourne: True
```

On peut aussi arriver au m√™me r√©sultat avec l'op√©rateur `-like` et les wildcards `*`.

```powershell
"Lorem ipsum" -like "*rem*"
#retourne: True
```



## (EXTRA) Expressions r√©guli√®res (regex)

Les expressions r√©guli√®res sont des cha√Ænes de caract√®res qui d√©crivent une multitude de cha√Ænes de caract√®res possibles. C‚Äôest comme les wildcards, mais beaucoup plus pr√©cis.

On utilise un regex en construisant un **pattern** suivant une syntaxe particuli√®re afin de d√©crire les r√®gles de correspondance d‚Äôun cha√Æne de caract√®res.

PowerShell supporte nativement les regex, par le biais de plusieurs commandes ou op√©rateurs, notamment:
- Les op√©rateurs `-match` et `-replace`
- La commande `Select-String`

L'op√©rateur `-match` est l'√©quivalent de `-like`, mais permet des patterns regex, qui sont beaucoup plus complexes et pr√©cis. L'op√©rande de gauche repr√©sente la cha√Æne √† tester, celle de droite repr√©sente le **pattern regex**. Le r√©sultat de l'op√©rateur est une valeur bool√©enne.

L'exemple suivant teste si la cha√Æne de caract√®re contient "oo".

```powershell
"google" -match "oo"
#retourne: True
```

Les patterns regex permettent des validation beaucoup plus pr√©cises. Voici quelques possibilit√©s que permettent les expressions r√©guli√®res.


### S√©lection de lettres

Si on sp√©cifie plusieurs lettres entre crochets, cela signifie qu'on permet une de ces lettres. Par exemple, pour le pattern `cr[iao]c`, on permet les cha√Ænes `cric`, `crac`, `croc`, mais pas `cruc`.

```powershell
"cric" -match "cr[iao]c"
# Retourne: True

"crac" -match "cr[iao]c"
# Retourne: True

"croc" -match "cr[iao]c"
# Retourne: True

"cruc" -match "cr[iao]c"
# Retourne: False
```

√Ä l'inverse, le pattern `cr[^iao]c` permet `cruc` mais pas `cric`. La lettre repr√©sent√©e par `[^iao]` peut √™tre n'importe quel caract√®re SAUF i, a et o.

```powershell
"cric" -match "cr[^iao]c"
# Retourne: False

"crac" -match "cr[^iao]c"
# Retourne: False

"croc" -match "cr[^iao]c"
# Retourne: False

"cruc" -match "cr[^iao]c"
# Retourne: True
```

### D√©but et fin de ligne

Par d√©faut, un pattern s'applique √† n'importe quelle partie de la cha√Æne. Par exemple, le pattern `cr[iao]c` signifie que la cha√Æne est valide si, √† n'importe quel endroit dans la cha√Æne, on retrouve un **c**, suivi d'un **r**, suivi d'un **i** ou d'un **a** ou d'un **o**, suivi d'un **c**.

```powershell
"cric" -match "cr[iao]c"
# Retourne: True

"crachat" -match "cr[iao]c"
# Retourne: True

"escroc" -match "cr[iao]c"
# Retourne: True
```

On peut sp√©cifier le d√©but ou la fin de la cha√Æne avec les caract√®res `^` et `$` respectivement.

```powershell
"cric" -match "^cr[iao]c$"
# Retourne: True

"crachat" -match "^cr[iao]c$"
# Retourne: False

"escroc" -match "^cr[iao]c$"
# Retourne: False
```

### Caract√®res sp√©cifiques

On peut sp√©cifier des cat√©gories de caract√®res sp√©cifiques.

| Code | Description |
| -- | -- |
| `\w` (minuscule) | Caract√®re alphanum√©rique (tous les chiffres et les lettres) |
| `\W` (majuscule) | Caract√®re non alphanum√©rique (caract√®res sp√©ciaux) |
| `\d` (minuscule) | Caract√®re num√©rique (chiffres de 0 √† 9) |
| `\D` (majuscule) | Caract√®re non num√©rique (lettres et caract√®res sp√©ciaux) |
| `\s` (minuscule) | Caract√®re blanc (espace, espace ins√©cable, etc.) |
| `\S` (majuscule) | Caract√®re non blanc |
| `[0-9]` | Plage de chiffres |
| `[a-z]` | Plage de lettres |
| `[a-zA-Z]` | Plage de lettres majuscule et minuscule |
| `.` | N'importe quel caract√®re |
| `\t` | Le caract√®re de tabulation (`U+0009`) |
| `\r` | Le caract√®re de retour de chariot (`U+000D`) |
| `\n` | Le caract√®re de saut de ligne (`U+000A`) |

```powershell
"42" -match "^\d\d$"
# Retourne: True

"42" -match "^\D\D$"
# Retourne: False

"42" -match "^[0-9][1-4]$"
# Retourne: True

"4x" -match "^\w\w$"
# Retourne: True

"&%" -match "^\W\W$"
# Retourne: True

"lol" -match "^[a-z][a-z][a-z]$"
# Retourne: True

"l0l" -match "^[a-z][a-z][a-z]$"
# Retourne: False

"cr&c" -match "^cr.c$"
# Retourne: True

"cr c" -match "^cr.c$"
# Retourne: True

"A 1" -match "^\S\s\S$"
# Retourne: True

"A-1" -match "^\S\s\S$"
# Retourne: False
```

### Valeurs √©num√©r√©es

Le caract√®re `|` permet d'√©num√©rer certaines valeurs possibles.

```powershell
"Il y a une erreur!" -match "erreur|error"
# Retourne: True

"There is an error!" -match "erreur|error"
# Retourne: True

"Il y a un probl√®me!" -match "erreur|error"
# Retourne: False
```


### Quantification

On peut d√©finir des r√©p√©titions de caract√®res dans un pattern regex. Voici la syntaxe √† utiliser:

| Code | Description |
| -- | -- |
| `*` | R√©p√©tition de 0 fois ou plus |
| `+` | R√©p√©tition de 1 fois ou plus |
| `?` | Pr√©sence 0 ou 1 fois seulement |
| `{n}` | Pr√©sent exactement n fois |
| `{n,m}` | Pr√©sent entre n et m fois |
| `{n,}` | Pr√©sent au minimum n fois |

Voici quelques exemples:

```powershell
$mots = @("Ggle", "Gogle", "Google", "Gooogle")

$mots | Where-Object { $_ -match '^Go*gle$'}
# Retourne: Ggle, Gogle, Google, Gooogle

$mots | Where-Object { $_ -match '^Go+gle$'}
# Retourne: Gogle, Google, Gooogle

$mots | Where-Object { $_ -match '^Go?gle$'}
# Retourne: Ggle, Gogle

$mots | Where-Object { $_ -match '^Go{2}gle$'}
# Retourne: Google

$mots | Where-Object { $_ -match '^Go{1,2}gle$'}
# Retourne: Gogle, Google

$mots | Where-Object { $_ -match '^Go{2,}gle$'}
# Retourne: Google, Gooogle
```


### Groupes de capture

Les patterns regex permettent de d√©finir des groupes de caract√®res, pour la r√©p√©tition ou encore l'extraction de leur valeur. On identifie les groupes entre parenth√®ses et leur valeur est r√©pertori√©e dans le *hashtable* contenu dans la variable `$Matches`.

```powershell
$Message = "The last logged on user was CONTOSO\jsmith"

$Message -match '(.+was )(.+)'
# Retourne: True

$Matches.0
# Retourne: la cha√Æne compl√®te

$Matches.1
# Retourne: "The last logged on user was "

$Matches.2
# Retourne: "CONTOSO\jsmith"
```

On peut donner des noms aux groupes. La syntaxe est alors: `(?<nomdugroupe>pattern)`.

```powershell
$Message = "The last logged on user was CONTOSO\jsmith"

$Message -match 'was (?<domain>.+)\\(?<user>.+)'
# Retourne: True

$Matches.domain
# Retourne: "CONTOSO"

$Matches.user
# Retourne: "jsmith"
```

Un groupe peut aussi servir d'unit√© de r√©p√©tition.

```powershell
"poutpout" -match '^(pout){3,}$'
# Retourne: False

"poutpoutpout" -match '^(pout){3,}$'
# Retourne: True

"poutpoutpoutpout" -match '^(pout){3,}$'
# Retourne: True
```

### Validation de param√®tre

Voici un exemple de pattern qui valide si une cha√Æne de caract√®re est un num√©ro de t√©l√©phone valide, sous forme `###-###-####`.

```powershell
"514-555-0123" -match '^\d{3}-\d{3}-\d{4}$'
# Retoure: TRUE

"(514) 555-0123" -match '^\d{3}-\d{3}-\d{4}$'
# Retoure: FALSE
```

On peut utiliser ce pattern dans une validation de param√®tre dans un script ou une fonction.

```powershell
param(
    [Parameter(Mandatory,ValueFromPipeline)]
    [ValidatePattern('^\d{3}-\d{3}-\d{4}$')]
    [string] $NumeroTelephone
)
```

### Caract√®re d'√©chappement

Dans un pattern, on peut repr√©senter la plupart des caract√®res, mais certains sont r√©serv√©s en ont une signification particuli√®re dans la syntaxe regex. Ces caract√®res sont: `[ ] ( ) . \ ^ $ | ? * + { }`

Pour utiliser ces caract√®res dans leur valeur lit√©rale au sein d'un pattern, ils doivent √™tre pr√©c√©d√©s d'un `\`. Ce caract√®re "annule" leur effet sur la syntaxe.

```powershell
"3.141" -match "3\.\d{2,}"
# Retourne: True

"C:\Windows" -match "^C:\\."
# Retourne: True
```

### Remplacement

L'op√©rateur -replace admet les expressions r√©guli√®res. Il permet de remplacer toutes les occurrences d'un pattern par une cha√Æne de caract√®res de remplacement.

```powershell
$message = "Mon num√©ro de t√©l√©phone est 450-555-0168 et mon cellulaire est 514-555-0666"
$message -replace "\d{3}-\d{3}-\d{4}", "confidentiel"

# Retourne: "Mon num√©ro de t√©l√©phone est confidentiel et mon cellulaire est confidentiel."
```

On peut aussi faire un remplacement en pr√©servant le contenu d'un groupe.

```powershell
'CONTOSO\jsmith' -replace '\w+\\(?<user>\w+)', 'MONDOMAINE\${user}'

# Retourne: "MONDOMAINE\jsmith"
```

