---
title: R09 - Requ√™tes WMI
slug: "09"
draft: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 9 - Requ√™tes WMI

:::note R√©sum√© de la s√©ance du jeudi 16 novembre 2023

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Pr√©sentation de WMI
2. Le langage WQL
3. Interrogation de WMI avec PowerShell
4. Outils d'exploration de WMI

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

Faites la partie 1 du [TP2](../tp/tp2.md#partie-1-script-de-lancement).

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::


WMI (Windows Management Instrumentation) est l'impl√©mentation par Microsoft du standard ouvert WBEM (Web-Based Enterprise Management) permettant la gestion centralis√©e et unifi√©e d'√©quipements informatiques en entreprise, lui-m√™me d√©riv√© d'un autre standard ouvert, CIM (Common Information Model). 

WMI a √©t√© introduit nativement dans Windows depuis Windows 2000, et est encore activement utilis√© aujourd'hui par des administrateurs de syst√®me afin de g√©rer des parcs informatiques de mani√®re centralis√©e et automatis√©e.


## √Ä quoi sert WMI?

Gr√¢ce √† WMI, on peut interroger et contr√¥ler le syst√®me d'exploitation Windows. WMI est en quelque sorte une librairie de classes servant √† acc√©der diff√©rentes ressources du syst√®me. Ces ressources sont, par exemple, les propri√©t√©s de notre ordinateur (mod√®le, fabricant, num√©ro de s√©rie, etc.), les diff√©rents composants mat√©riels, les applications install√©es, la configuration r√©seau, etc.

Bien s√ªr, PowerShell offre certaines commandes servant √† obtenir des informations sur le syst√®me. Par exemple, Get-Process, Get-Service, Get-LocalUser, etc. Mais souvent, ces commandes utilisent WMI en arri√®re-plan. WMI est beaucoup plus grand et vaste que ce que les commandes PowerShell peuvent nous offrir.

Voici quelques exemples de ce qu'on peut faire avec WMI dans un script:

- Savoir si le PC est un portable, un ordinateur de table, un serveur tour, un serveur en rack, etc.
- Conna√Ætre le mod√®le du PC, son fabricant, son num√©ro de s√©rie, etc.
- Obtenir la liste de tous les p√©riph√©riques branch√©s
- Obtenir le mod√®le et le num√©ro de s√©rie de la batterie d'un laptop
- Obtenir la configuration de la table de routage interne de Windows
- Obtenir la liste et la date d'installation de toutes les mises √† jour de Windows install√©es
- Obtenir la liste des imprimantes configur√©es
- Obtenir la liste des partages r√©seau
- Obtenir la liste de toutes les cartes r√©seau configur√©es, avec leur adresses MAC et IP
- Et de nombreuses autres choses, dont certaines impossibles √† faire avec les consoles et les commandes existantes.

Et encore l√†, ce n'est que la superficie de ce que WMI permet de r√©aliser. Autrement dit, WMI donne √† nos script la possibilit√© d'administrer le syst√®me sur lequel il est lanc√©‚Ä¶ et m√™me sur des ordinateurs distants!

Conna√Ætre comment utiliser WMI est vraiment essentiel pour tout administrateur Windows.


## Architecture du service WMI

WMI est structur√©e en trois principales couches: Les fournisseurs (providers), l'infrastructure et les consommateurs (consumers).

![](./assets/r09/wmi_architecture.png)


### Les objets g√©r√©s et les providers WMI

Un objet g√©r√© (*managed object*) est un composant logiciel ou mat√©riel, tel qu'un disque dur, une carte r√©seau, un processus, un service, une application, etc. Ces objets sont acc√©d√©s par un fournisseur (*WMI provider*) qui, √† la mani√®re d'un driver, rendent accessibles certaines informations et fonctions les concernant, sous forme de classes. Ces classes poss√®dent des propri√©t√©s et des m√©thodes, et d√©finissent la nature des objets, lesquels peuvent √™tre pr√©sents en plusieurs instances.

Sous Windows, plusieurs fournisseurs WMI de base sont pr√©install√©s. Ainsi, le fournisseur `StrRegProv` permet d'interroger la base de registre de Windows √† travers WMI, et le fournisseur Win32 permet de manipuler et d'interroger les propri√©t√©s du syst√®me d'exploitation (processus, services, etc.)

### Infrastructure WMI

L'infrastructure WMI est un composant de Windows servant √† rendre accessibles les objets g√©r√©s WMI aux consommateurs. √Ä l'instar d'un syst√®me de base de donn√©es, elle comprend un repository (une sorte de base de donn√©es) ainsi qu'un service pour traiter les requ√™tes.

Le repository est organis√© sous forme de namespaces, de sorte √† former une arborescence sous une racine appel√©e `ROOT`. Dans ces namespaces se retrouvent les diff√©rentes classes offertes par les providers. Certains namespaces sont cr√©√©s automatiquement par le service WMI, mais la plupart sont cr√©√©s par les diff√©rents providers enregistr√©s dans le syst√®me.

√Ä la mani√®re d'une base de donn√©es, on peut interroger le repository en envoyant des requ√™tes √† un service charg√© de les traiter. Ce service se nomme winmgmt et fait partie des services de base de Windows. De plus, le service WMI peut √™tre acc√©d√© √† distance √† travers le r√©seau (√† condition que le consommateur dispose de droits d'administration sur la machine distante et que le pare-feu soit correctement configur√©).


### Consommateurs WMI

Le consommateur WMI est toute application ou script qui souhaite interroger la base WMI. Il peut √©num√©rer les *namespaces*, les classes et leurs instances (objets), interroger leurs propri√©t√©s et ex√©cuter leurs m√©thodes. Les scripts d'administration sous Windows sont tr√®s fr√©quemment des consommateurs WMI, puisque c'est souvent l'unique mani√®re d'interagir avec certaines propri√©t√©s du syst√®me d'exploitation.


### Le *WMI Repository*

Essentiellement, la base WMI est compos√©e d'espaces de nommage, ou *namespaces*, dispos√©s en arborescence sous la racine `ROOT`. Le *namespace* le plus couramment utilis√© dans les scripts d'administration est `ROOT\cimv2`, et il est g√©n√©ralement consid√©r√© comme le *namespace* par d√©faut.

Dans ce *namespace* se trouvent les classes qui permettent d'obtenir des informations sp√©cifiques √† Windows. Ces classes ont un nom qui d√©bute par le pr√©fixe Win32. Il existe d'autres classes dans ce *namespace*, dont plusieurs commencent par le pr√©fixe CIM, mais elle ne sont pas int√©ressantes puisque plus limit√©es. Elle sont seulement l√† pour respecter le standard CIM duquel WMI est inspir√©.

Les ressources du syst√®me sont des instances de ces classes, ou objets, qui poss√®dent des propri√©t√©s et des m√©thodes. Cette structure est directement inspir√©e par le paradigme orient√©-objet.

![](./assets/r09/wmi_structure.png)

L'illustration ci-dessous montre l'outil [WMI Explorer](https://github.com/vinaypamnani/wmie2/releases), permettant de naviguer au sein du repository WMI. Vous y voyez, de gauche √† droite, les namespaces, les classes pr√©sentes dans le namespace s√©lectionn√©, les instances de cette classe, ainsi que les propri√©t√©s de l'instance. Dans cet exemple, la classe `Win32_LocalDisk` d√©finit ce qu'est un disque logique, et chaque instance de cette classe repr√©sente un disque logique reconnu par Windows. Chaque disque logique poss√®de des propri√©t√©s uniques, comme une lettre, une taille, un syst√®me de fichiers, etc. 

Cette application interroge le service WMI de la m√™me mani√®re que vous pourriez le faire dans vos scripts. De ce fait, WMI un outil tr√®s puissant lorsqu'il est question de d√©velopper des scripts administratifs.

![](./assets/r09/wmi_explorer.png)


### Le langage WQL

Le langage WQL (WMI Query Language) est un d√©riv√© du SQL et sert √† effectuer des requ√™tes au service WMI.

Pour effectuer une requ√™te simple, on utilise la clause `SELECT` pour sp√©cifier le nom des propri√©t√©s √† inclure √† la requ√™te et la clause `FROM` pour sp√©cifier la classe WMI.

```sql
SELECT Name, FileSystem, Size, FreeSpace FROM Win32_LogicalDisk
```

On peut voir toutes les propri√©t√©s avec `SELECT *`.

```sql
SELECT * FROM Win32_LogicalDisk
```

On peut ajouter un filtre √† l'aide de la clause `WHERE` avec une condition (*propri√©t√© op√©rateur constante*).

```sql
SELECT * FROM Win32_LogicalDisk WHERE FileSystem = 'NTFS'
```

Les op√©rateurs admissibles sont:

| Op√©rateur | Description |
| -- | -- |
| **=** | √âgal √† |
| **<** | Plus petit que |
| **\>** | Plus grand que |
| **<=** | Plus petit ou √©gal √† |
| **\>=** | Plus grand ou √©gal √† |
| **!=** ou **<\>** | Diff√©rent de |
| **IS NULL** | Est nul |
| **IS NOT NULL** | N'est pas nul |
| **AND** | Et logique (pour sp√©cifier plusieurs conditions) |
| **OR** | Ou logique (pour sp√©cifier plusieurs conditions) |
| **NOT** | Non logique |
| **LIKE** | Comparaison de cha√Æne de caract√®re avec *wildcard* |

Les wildcards admissibles avec l'op√©rateur `LIKE` sont:

| *Wildcard* | Description |
| -- | -- |
| **%** | N'importe quelle cha√Æne de 0 ou plus caract√®res |
| **_** | N'importe quel caract√®re (un seul) |
| **[ ]** | Un caract√®re parmi les caract√®res en crochet (`[a-f]` ou `[abcdef]`) |
| **[^ ]** | Un caract√®re autre que ceux sp√©cifi√©s en crochet (`[^a-f]` ou `[^abcdef]`) |

Voici un exemple de requ√™te permettant d'obtenir toutes les imprimantes locales de marque HP.

```sql
Select * FROM Win32_Printer WHERE Local="TRUE" AND DriverName LIKE "%HP%"
```

## Utilisation de WMI avec PowerShell

Il existe plusieurs mani√®res d'interroger le service WMI, mais la plus simple en PowerShell consiste √† utiliser la commande `Get-WmiObject`, ou son alias `gwmi`.

La principale utilisation de la commande `Get-WmiObject` vise √† obtenir une ou plusieurs instances d'une classe dans un *namespace* donn√©. Il en r√©sulte √† sa sortie un tableau d'objets qui poss√®dent les propri√©t√©s et les m√©thodes d√©finis par leur classe.

![](./assets/r09/gwmi01.png)

Cette commande se comporte comme la plupart des commandes PowerShell, en ce sens qu'elle retourne un objet. Cet objet peut √™tre manipul√© √† l'instar de tous les objets PowerShell.

![](./assets/r09/gwmi02.png)


Le param√®tre `-Namespace` est optionnel. Lorsqu'il est omis, la commande regarde dans `ROOT\cimv2`. Et on peut sp√©cifier la classe sans devoir sp√©cifier le nom du param√®tre `-Class`. 

![](./assets/r09/gwmi03.png)


Les objets correspondant √† une instance de classe WMI sont de type ManagementObject.

![](./assets/r09/gwmi04.png)


## Commande *Get-WmiObject*


Voici les principaux param√®tres qu'on peut fournir √† `Get-WmiObject`:

| Param√®tre | Description |
| -- | -- |
| `-Class` | Nom de la classe WMI dont on veut obtenir les instances. |
| `-Property` | Propri√©t√©(s) √† r√©cup√©rer (pour s'√©viter un `Select-Object`) |
| `-Namespace` | Le *namespace* o√π se trouve la classe. Si ce param√®tre n'est pas sp√©cifi√©, c'est `ROOT\cimv2` qui est pris par d√©faut |
| `-Filter` | Sp√©cifie un filtre pour ne retourner que certains objets selon les crit√®res sp√©cifi√©s. Attention, ce param√®tre n'a pas la syntaxe PowerShell mais WQL (proche du SQL). |
| `-Query` | Au lieu des param√®tres `-Class`, `-Property` et `-Filter`, on peut d√©finir une cha√Æne de caract√®re repr√©sentant une requ√™te WQL (par exemple, `SELECT * FROM Win32_LogicalDisk WHERE FileSystem = 'NTFS'`) |
| `-ComputerName` | Nom de l'ordinateur sur lequel on veut effectuer la requ√™te. Si ce param√®tre n'est pas sp√©cifi√©, c'est "`.`" qui est sa valeur par d√©faut, ce qui correspond √† la machine locale. |
| `-Credential` | Objet de type `[PSCredential]` pour l'authentification. Cette notion sera couverte plus tard. |
| `-List` | Affiche la liste des classes du *namespace* (soit celui sp√©cifi√© dans le param√®tre `-Namespace`, soit `ROOT\cimv2` par d√©faut) |

En sortie, `Get-WmiObject` envoie dans le pipeline un tableau d'objets de type `[ManagementObject]`, ou un objet unique lorsqu'il n'y a qu'une instance. Cet objet peut √™tre affect√© √† une variable, ou pass√© √† une autre commande via le pipeline, comme les commandes `Format-`, `Out-`, `Sort-`, `Select-`, etc. Autrement, cet objet tombe dans l'h√¥te et est converti en texte.

![](./assets/r09/gwmi05.png)

On voit cependant que cette commande retourne aussi certaines propri√©t√©s syst√®me propres √† WMI, alors il peut √™tre int√©ressant de passer cet objet dans un `Select-Object` pour s√©lectionner les propri√©t√©s qu'on veut.

![](./assets/r09/gwmi06.png)

:::tip
Le param√®tre `-Property` de `Get-WmiObject` peut quand m√™me √™tre pratique en conjonction avec `Select-Object`, car certains objets WMI ont un grand nombre de propri√©t√©s. WMI est un syst√®me particuli√®rement lent, alors si vous ne sp√©cifiez pas les propri√©t√©s dans `Get-WmiObject`, √ßa pourrait nuire √† la performance de votre script.
:::


## √ânum√©ration des classes WMI

On peut obtenir la liste des classes avec `Get-WMIObject -List`. Par d√©faut, on recherche dans le namespace `cimv2`.

![](./assets/r09/gwmi07.png)

Pour une recherche plus pr√©cise, on peut sp√©cifier un **filtre**.

![](./assets/r09/gwmi08.png)


### Quelques classes int√©ressantes

Voici quelques classes particuli√®rement utiles sous `ROOT\cimv2`:

| Classe | Description |
| -- | -- |
| `Win32_ComputerSystem` | Informations de base sur le syst√®me, comme le mod√®le et le fabricant, le hostname, le domaine AD, le fuseau horaire, le nombre de processeurs logiques, etc. |
| `Win32_NetworkAdapter` | Cartes r√©seau (physiques et logiques) install√©es. |
| `Win32_NetworkAdapterConnection` | Configuration des cartes r√©seau (puisqu'une carte r√©seau peut avoir plusieurs connections, il doit y avoir une classe diff√©rente) |
| `Win32_NetworkConnection` | Partages r√©seau mapp√©s. |
| `Win32_LogicalDisk` | Les disques durs logiques (C:, D:, etc.) |
| `Win32_Account` | Comptes utilisateurs et des groupes locaux. |
| `Win32_UserAccount` | Comptes utilisateurs locaux |
| `Win32_Group` | Groupes locaux |
| `Win32_NTLogEvent` | √âv√©nements du journal d'√©v√©nements Windows |
| `Win32_Process` | Processus en ex√©cution |
| `Win32_Service` | Services |
| `Win32_SystemEnclosure` | Information sur le bo√Ætier et le facteur de forme (par exemple, pour distinguer les laptops, les tours, les serveurs rackmount, les tablettes, etc.) |
| `Win32_BIOS` | Information sur le BIOS (fabricant, version, r√©vision, etc.) |
| `Win32_Battery` | Information sur la batterie (charge restante...) |


## Collectins d'objets et filtrage

Certaines classes n'ont qu'une seule instance (par exemple, `Win32_ComputerSystem`), mais d'autres en ont plusieurs. Lorsqu'on ex√©cute une requ√™te WMI sur ces classes, on obtient un tableau d'objets.

![](./assets/r09/gwmi09.png)

Il se trouve que par d√©faut, `Get-WmiObject` est format√©e en liste plut√¥t qu'en tableau. Mais il s'agit bel et bien d'un objet et on peut le manipuler de la m√™me mani√®re que toutes les autres collections PowerShell.

![](./assets/r09/gwmi10.png)

Si on veut une instance sp√©cifique, on doit d√©finir un filtre. Il y a plusieurs mani√®res de proc√©der.


### Avec *Where-Object*

On peut utiliser l'habituelle commande `Where-Object` pour filtrer une collection et ne garder qu'une ou certaines de ses instances.

![](./assets/r09/gwmi11.png)

Ou on peut aussi utiliser cette m√©thode pour obtenir une collection plus petite de toutes les instances qui ob√©issent √† une condition pr√©cise. 

Dans cet exemple, on filtre pour ne retenir que les disques locaux et non les disques r√©seau. Selon la documentation, la propri√©t√© `DriveType` prend la valeur 3 pour un disque local et 4 pour un lecteur r√©seau. 

![](./assets/r09/gwmi12.png)

### Dans la requ√™te WMI

On peut utiliser le param√®tre `-Filter` de `Get-WmiObject` pour d√©finir les crit√®res.

![](./assets/r09/gwmi13.png)

Cette technique pr√©f√©rable √† `Where-Object` dans la plupart des cas, car avec cette derni√®re, toutes les instances circulent dans le pipeline avant le `Where-Object`. 

Supposons que le r√©sultat de la requ√™te `Get-WmiObject` donnait un million d'instances. Avec `Where-Object`, il aurait fallu accumuler un million d'objets dans le pipeline, avant le filtrage. Lorsqu'on sp√©cifie le filtre dans la requ√™te WMI, on √©vite de manipuler les objets qu'on ne veut pas. Ainsi, on gagne en performance et on √©vite de surutiliser la m√©moire du syst√®me.

Le d√©savantage de cette m√©thode, c'est que les crit√®res doivent √™tre d√©finis en WQL et non en PowerShell. WQL est un langage plus limit√© que PowerShell. Il arrive parfois qu'on doive faire une partie du travail de filtrage par la requ√™te WMI, puis une autre passe, plus fine, avec `Where-Object`.


### Dans une requ√™te WQL

Lorsqu'on choisit d'utiliser une requ√™te WQL, le filtre doit √™tre d√©fini apr√®s la clause `WHERE`, de la m√™me mani√®re qu'en SQL.

![](./assets/r09/gwmi14.png)


## Membres des objets

La commande `Get-WmiObject` s'utilise de la m√™me mani√®re que `Get-Process`, `Get-Service` ou `Get-ChildItem`. Il sort de cette commande un objet (lorsque WMI ne poss√®de qu'une seule instance de cette classe) ou un tableau d'objets (lorsque WMI poss√®de plusieurs instances). Ces objets ont des membres (des propri√©t√©s et des m√©thodes) correspondant √† celles de leur classe. Les techniques pour explorer ces objets √† la recherche de ce qu'on peut exploiter sont donc semblables √† ce qu'on peut faire avec les objets retourn√©s par les commandes natives de PowerShell.

La classe `Win32_OperatingSystem` d√©finit plusieurs propri√©t√©s d'un syst√®me d'exploitation Windows. Comme il n'y a qu'un seul syst√®me d'exploitation actif dans un syst√®me, il n'y a qu'un objet, et non une instance d'objets, qui sort de la commande. Avec un `Select-Object *` ou un `Format-List *`, on peut forcer PowerShell √† afficher toutes les propri√©t√©s de l'objet.

![](./assets/r09/gwmi15.png)

S'il y a plusieurs instances de la classe recherch√©e, il faut √™tre un peu plus cr√©atif. On pourrait s√©lectionner un seul objet pour observer son contenu:

![](./assets/r09/gwmi16.png)

Ou encore utiliser `Out-GridView`‚Ä¶

![](./assets/r09/gwmi17.png)

Ou bien exporter en CSV pour pouvoir importer directement dans Excel!

![](./assets/r09/gwmi18.png)

Une autre approche consiste √† utiliser `Get-Member`. On peut voir les propri√©t√©s, mais aussi les m√©thodes pouvant √™tre appel√©es sur cet objet. On peut aussi conna√Ætre le type de donn√©es de ces propri√©t√©s. Cependant, cela ne nous permet pas de voir le contenu.

![](./assets/r09/gwmi19.png)

On peut aussi utiliser le param√®tre `-MemberType` de `Get-Member` pour n'afficher que les propri√©t√©s ou les m√©thodes.

![](./assets/r09/gwmi20.png)


### Propri√©t√©s

On interroge les propri√©t√©s d'un objet WMI de la m√™me mani√®re que sur un objet ordinaire. On peut manipuler les propri√©t√©s √† notre guise et faire toutes les manipulations qu'on souhaite.

![](./assets/r09/gwmi21.png)

### M√©thodes

Il y a plus d'une mani√®re d'appeler une m√©thode sur un objet WMI.


#### Option 1: Par un appel de m√©thode sur l'objet

Cette technique revient √† simplement appeler une m√©thode comme vous √™tes habitu√©s de le faire. L'exemple ici se fait avec une variable pour, mais on pourrait tr√®s bien le faire sur la m√™me ligne.

![](./assets/r09/gwmi22.png)

Notez ci-dessus qu'un objet est retourn√©. Cet objet sert transmettre au consommateur de WMI un code de retour, o√π 0 signifie un succ√®s, et n'importe quelle autre valeur signifie qu'une erreur est survenue.

Lorsqu'il y a plusieurs processus du m√™me nom (ici, deux processus *notepad.exe*), alors la m√©thode est ex√©cut√©e √† chacun des objets, sans qu'on n'ait besoin de faire une boucle.

![](./assets/r09/gwmi23.png)

#### Option 2: Avec la commande *Invoke-WmiMethod*

On peut aussi utiliser la commande `Invoke-WmiMethod`. Il suffit de lui passer un objet WMI dans le pipeline et sp√©cifier le nom de la m√©thode.

![](./assets/r09/gwmi24.png)

#### Passage de param√®tres

On peut passer des param√®tres aux m√©thodes WMI. Cependant, il faut souvent se fier √† la documentation de Microsoft pour conna√Ætre quels param√®tres passer et dans quel format.

![](./assets/r09/gwmi25.png)


#### Cacher l'objet de retour

Si, dans votre script, vous souhaitez invoquer une m√©thode d'un objet WMI, vous ne voulez pas vraiment que le script affiche l'objet de retour.

![](./assets/r09/gwmi26.png)

Une mani√®re de faire est d'affecter cet objet dans une variable. Ainsi, il ne tomberait pas dans la console √† la fin du pipeline. Cependant, ce n'est pas propre puisqu'on utilise de la m√©moire inutilement (√† moins, bien s√ªr, qu'on souhaite utiliser cet objet par la suite).

![](./assets/r09/gwmi27.png)

On pourrait aussi affecter cet objet dans une variable, mais cette fois, dans la variable $null. Cette variable est sp√©ciale car elle est toujours vide. Donc si on affecte l'objet dans cette variable, il n'aboutit pas dans la console et sa r√©f√©rence est instantan√©ment d√©truite.

![](./assets/r09/gwmi28.png)

Il y a une mani√®re plus propre et beaucoup plus explicite d'envoyer un objet dans le n√©ant. Il suffit de terminer le pipeline avec la commande de sortie Out-Null.

![](./assets/r09/gwmi29.png)


## Outils

Plusieurs outils permettent d'explorer WMI de mani√®re conviviale. Cela peut vous aider grandement dans vos scripts!

### WBEMTest

C'est un outil inclus dans Windows. Il permet d'explorer WMI, mais il est difficile √† utiliser et peu convivial. WMI est beaucoup plus vaste et complexe que ce qui est couvert dans ce cours, et cet outil permet d'explorer la m√©canique interne de WMI. Par contre, l'outil est inclus dans Windows (tapez simplement "wbemtest" dans une ligne de commande pour le lancer), ce qui vous √©vite de devoir t√©l√©charger un outil.

![](./assets/r09/outil_wbemtest.png)

Voici l'article de la documentation portant sur cet outil:
https://docs.microsoft.com/en-us/mem/configmgr/develop/core/understand/introduction-to-wbemtest


### WMIExplorer 2.0

Cet outil est le meilleur que je connaisse, et il est gratuit. Il peut se connecter sur la machine locale ou une machine distante sur le r√©seau, et permet de g√©n√©rer des scripts automatiquement! Je vous encourage fortement √† l'essayer.

![](./assets/r09/outil_wmiexplorer2.png)


Vous pouvez le t√©l√©charger ici:
https://github.com/vinaypamnani/wmie2/releases/latest 


### PowerShell WMI Browser
Cet outil est aussi gratuit et t√©l√©chargeable sur Internet. Il n'est pas aussi avanc√© que WMIExplorer, mais il est programm√© compl√®tement en PowerShell! Vous pouvez voir son code.

![](./assets/r09/outil_wmibrowser.png)

Oui, on peut faire des interfaces graphiques en PowerShell! :-)

Vous pouvez le t√©l√©charger ici: 
https://jdhitsolutions.com/blog/powershell/2848/wmi-explorer-from-the-powershell-guy/

Il y en a d'autres, mais ils sont soit payants ou d√©suets. Les outils ci-dessus, en plus de la commande `Get-WmiObject`, vous donneront tout ce qu'il vous faut pour utiliser WMI!


## WMI Explorer 2.0 (mon pr√©f√©r√©)

Cet outil est le meilleur que je connaisse, et il est gratuit. Vous pouvez le t√©l√©charger sur le site GitHub de son d√©veloppeur (https://github.com/vinaypamnani/wmie2/releases/latest)

Lorsque vous ouvrez cet outil, vous pouvez parcourir les diff√©rents namespaces. Un double-clic sur le namespace √©num√®re ses classes, et un double-clic sur une classe √©num√®re ses instances. Finalement, s√©lectionnez une instance et vous aurez toutes ses propri√©t√©s. Vous pouvez sp√©cifier un ordinateur diff√©rent du votre (le "." r√©f√®re √† l'ordinateur local). En prime, vous avez en tout temps au bas de la fen√™tre la requ√™te WQL correspondant √† l'instance que vous avez s√©lectionn√©e.

![](./assets/r09/outil_wmie01.png)

Dans l'onglet Properties, vous avez une liste de toutes les propri√©t√©s de la classe s√©lectionn√©e, tir√©e de la documentation de WMI.

![](./assets/r09/outil_wmie02.png)

Et dans l'onglet Methods, vous avez la m√™me chose mais pour les m√©thodes, avec la d√©finition des param√®tres d'entr√©e et de sortie. Attention, ces m√©thodes ne se comportent pas comme des m√©thodes classique appel√©es dans PowerShell, et il peut √™tre un peu ardu de les utiliser.

![](./assets/r09/outil_wmie03.png)

D'ailleurs, pour ex√©cuter une m√©thode, il suffit de cliquer-droit sur l'instance (pour un m√©thode non statique) ou sur la classe (pour une m√©thode statique).

![](./assets/r09/outil_wmie04.png)

Mais l√† o√π cet outil devient vraiment int√©ressant (et presque de la triche), c'est dans l'onglet Script. Vous pouvez g√©n√©rer automatiquement un bout de code PowerShell qui r√©cup√®re toutes les propri√©t√©s des instances de la classe, et le coller dans votre script. Le bout de code tel quel ne sert pas √† grand-chose, mais il vous donne un exemple d'utilisation de toutes les propri√©t√©s des objets. Vous n'avez ensuite √† prendre ce que vous voulez. L'outil ne fait pas tout le travail, mais en fait une partie √† votre place. 

![](./assets/r09/outil_wmie05.png)

